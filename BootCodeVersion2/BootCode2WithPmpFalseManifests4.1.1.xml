<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Når man tænder, er hele flash read-only og locked.
// Når man har verificeret noget, "åbner" man en region gennem PMP, så det kan eksekveres.
/*
TEST PURPOSE KEY PAIR:
Private Key: (143, 103)
Public Key: (143, 7)
Primes: p = 11, q = 13
Totient = 120
*/
const int MemoryMaxIndex = 100;
const int NumberOfFlashBanks = 1; 
const int NumberOfKeysInWhitelist = 1; //Calculated ids will always be either 1 or 0 so more ids in whitelist does not add anything atm.

typedef struct{
    int identifier;
    int rom_ext_slot[NumberOfFlashBanks]; // Address of Flash Bank
    
    //what to do if all ROM Ext are invalid
    //void (*fail) ();    
    int fail_function_address;

    //what to do if the ROM Ext unexpectedly returns
    //void (*fail_rom_ext_terminated) (rom_ext_manifest_t);   
    int rom_ext_failure_function_address;
} boot_policy_t;

typedef struct {
    int[0,1] exponent;
    int[0,1] modulus;
} pub_key_t; // If both fields of this struct are 1 then it evaluates to a correct key

typedef struct {
    int exponent;
    int modulus;
} sig_key_t;

typedef struct {
    int[0,2] identifier; // 0 -&gt; missing, 1 -&gt; contains magic value, 2 -&gt; does not contain magic value
    int entryPoint; //address in memory
    pub_key_t publicKey; // The public key used to verify the signature of the manifest
    int[0,2] signature; // 0 -&gt; missing, 1 -&gt; correct signature, 2 -&gt; bad signature
    //pub_key_t pub_signature_key;
    int[0,2] image_code; // 0 -&gt; missing, 1 -&gt; correct image code, 2 -&gt; hashed image code
} rom_ext_manifest_t;

typedef struct {
    int size;
    rom_ext_manifest_t rom_exts_mfs[NumberOfFlashBanks]; 
} rom_exts_manifests_t;

typedef struct{
    int startAddress;
    int endAddress;
    bool read;
    bool write;
    bool execute;
    bool locked;
} PmpRegion_t;

typedef struct{
    int Reg1;
    int Reg2;
    int Reg3;
    int Reg4;    
    int Reg5;
} life_cycle_state_t;

PmpRegion_t PmpRegions[16];

//int GlobalMemory[MemoryMaxIndex];
boot_policy_t GlobalBootPolicy;
rom_exts_manifests_t GlobalRomExtsManifests;
pub_key_t GlobalPublicKey;
//bool GlobalBool;
int GlobalSignature;
int GlobalImageCode;
int GlobalSecretKey;
int GlobalKMACResult;
rom_ext_manifest_t GlobalManifest;
life_cycle_state_t GlobalLifeCycleState;
bool GlobalMemoryIsScrambled; // Indicates whether the most recently read memory was scrambled or not.
int[0, NumberOfKeysInWhitelist] GlobalPublicKeyIdWhitelist[NumberOfKeysInWhitelist];

broadcast chan PowerOnBC;
chan StartRomStage;

chan CheckRomExtManifestCall,
     CheckRomExtManifestValid,
     CheckRomExtManifestNotValid;

chan TryReadMemory[MemoryMaxIndex][MemoryMaxIndex];
chan TryWriteMemory[MemoryMaxIndex][MemoryMaxIndex];
chan TryExecuteMemory[MemoryMaxIndex][MemoryMaxIndex];

chan ReadBootPolicyCall,
     ReadBootPolicyReturn;

chan REMTTCall, // Rom Ext Manifests To Try
     REMTTReturn;

chan PmpWriteMemory[MemoryMaxIndex][MemoryMaxIndex],
     PmpReadMemory[MemoryMaxIndex][MemoryMaxIndex];

chan FinalJumpCall,
     FinalJumpReturn;

chan Rom_Ext_Fail;
broadcast chan RaiseExceptionBC;

chan ReadPublicKeyCall, 
     ReadPublicKeyReturn;

chan HMACReturn,
     HMACCalled;

chan KMACReturn,
     KMACCalled;

chan RequestLifeCycleState,
     ReturnLifeCycleState;

chan FlashReadReturn;

broadcast chan CheckPublicKeyValidCallBC,
               PubKeyNotValidBC,
               PubKeyValidBC;

broadcast chan CheckSignatureBC,
               SignatureValidBC,
               SignatureNotValidBC;

broadcast chan RomExtValidBC[MemoryMaxIndex],
               RomExtNotValidBC;

chan RomExtStart[MemoryMaxIndex];
chan ReturnSecretKey,
     RequestSecretKey;

chan AdvanceKMState;

chan FlashRead[MemoryMaxIndex][MemoryMaxIndex],
     FlashWrite[MemoryMaxIndex][MemoryMaxIndex];

//SRAM Controller channels
chan CheckSRAM[MemoryMaxIndex][MemoryMaxIndex],
     CheckSRAMReturn,
     NotInSRAM;
chan ReadSRAM[MemoryMaxIndex][MemoryMaxIndex],
     ReadSRAMReturn;
chan WriteSRAM[MemoryMaxIndex][MemoryMaxIndex],
     WriteSRAMReturn;
    


chan RequestScrambleKey,
     ReturnScrambleKey;

//Channels for overall memory handling (reading from SRAM or Flash)
chan ReadMemory[MemoryMaxIndex][MemoryMaxIndex],
     ReadMemoryReturn;

chan WriteMemory;
void clearGlobalMemory(){
    int i;
    //for(i = 0; i &lt; MemoryMaxIndex; i++)
       // GlobalMemory[i] = 0;
}

void clearGlobalBootPolicy(){
    int i;
    GlobalBootPolicy.identifier = 0;
    for(i = 0; i &lt; NumberOfFlashBanks; i++)
        GlobalBootPolicy.rom_ext_slot[i] = 0; 
    GlobalBootPolicy.fail_function_address = 0;  
    GlobalBootPolicy.rom_ext_failure_function_address = 0;
}

void clearGlobalRomExtsManifests(){
    int i, j;
    GlobalRomExtsManifests.size = 0;
    for(i = 0; i &lt; NumberOfFlashBanks; i++){
        GlobalRomExtsManifests.rom_exts_mfs[i].identifier = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].entryPoint = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].signature = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].image_code = 0;
    }
}

void ClearGlobalPublicKey(){
    GlobalPublicKey.exponent = 0;
    GlobalPublicKey.modulus = 0;
}

void ClearGlobalPubKeyWhitelist(){
    int i;
    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++) 
        GlobalPublicKeyIdWhitelist[i] = 0;
}

int PowerMod(int root, int exponent, int modulus){ // root ^ exponent % modulus
    int result = 1;
    int i;    

    if (root == 0 || modulus == 0)
        return 0;
    if (exponent == 0)
        return 1;

    for(i = 0; i &lt; exponent; i++){
        result *= root;
        result %= modulus;
    }

    return result;
}

void ClearGlobalManifest(){
    int i;
    GlobalManifest.identifier = 0;
    GlobalManifest.entryPoint = 0;
    GlobalManifest.publicKey.exponent = 0;
    GlobalManifest.publicKey.modulus = 0; 
    GlobalManifest.image_code = 0;
    GlobalManifest.signature = 0;
}

void ClearGlobalLifeCycleState(){
    GlobalLifeCycleState.Reg1 = 0;
    GlobalLifeCycleState.Reg2 = 0;
    GlobalLifeCycleState.Reg3 = 0;    
    GlobalLifeCycleState.Reg4 = 0;
    GlobalLifeCycleState.Reg5 = 0;
}
</declaration>
	<template>
		<name>SystemReset</name>
		<location id="id0" x="187" y="-51">
		</location>
		<location id="id1" x="51" y="-51">
		</location>
		<location id="id2" x="-51" y="-51">
		</location>
		<init ref="id2"/>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="59" y="-76">StartRomStage!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-42" y="-76">PowerOnBC!</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Flash</name>
		<declaration>//int memory[MemoryMaxIndex];
// 0-19 ROM
// 20-29 Flash Info
// 30-64 Flash Bank 0
// 65-99 Flash Bank 1
/*
Flash Bank has size 35. 
The 12 first indexes are for manifest of following structure:
0: Identifier
1: Signature
2-7: Public Key
8-11: Image Code
*/
rom_exts_manifests_t manifests;
int[0, NumberOfKeysInWhitelist] pubKeyWhitelist[NumberOfKeysInWhitelist];


void loadManifest(){
    int i, j;
    rom_ext_manifest_t tempManifest;
    //Create manifest for Flash Banks
    for(i = 0; i &lt; NumberOfFlashBanks; i++){
        tempManifest.identifier = i % 2;
        tempManifest.entryPoint = 38 + (35 * i);
        
        
        
        manifests.rom_exts_mfs[i] = tempManifest;
    }
}

void initializeMemory(){
    int i;
    loadManifest();
    
    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++){
        pubKeyWhitelist[i] = i + 1;
    }
}

void readMemory(int startIndex, int endIndex){
    if(startIndex &gt;= 0 &amp;&amp; endIndex &lt;= 19){
        //Something from ROM
        if (startIndex == 13 &amp;&amp; endIndex == 13){ // public key id whitelist used for public key verification.
            GlobalPublicKeyIdWhitelist = pubKeyWhitelist; //Should be changed to an actual transference of an array from flash into the global array
            GlobalMemoryIsScrambled = true;
        }
    }
    if(startIndex &gt;= 20 &amp;&amp; endIndex &lt;= 29){
        //Something from Flash Info
    }
    if(startIndex &gt;= 30 &amp;&amp; endIndex &lt;= 64){
        //Something from Flash Bank 0
        if(startIndex == 30 &amp;&amp; endIndex == 41){
            GlobalManifest = manifests.rom_exts_mfs[0];
            GlobalMemoryIsScrambled = true;
        }

    }
    if(startIndex &gt;= 65 &amp;&amp; endIndex &lt;= 99){
        //Something from Flash Bank 1
        if(startIndex == 65 &amp;&amp; endIndex == 76){
            GlobalManifest = manifests.rom_exts_mfs[1];
        }
    }
    else{
        if (startIndex == 100){
            GlobalManifest = manifests.rom_exts_mfs[2];
        }
        else if (startIndex == 135){
            GlobalManifest = manifests.rom_exts_mfs[3];
        }
        //You fucked up
    }
}

/*

void readMemory(v){
    int i;
    for(i = 0; i &lt;= endIndex - startIndex; i++){
        GlobalMemory[i] = memory[i + startIndex];
    }
}
*/
void writeMemory(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt;= endIndex - startIndex; i++){
        //memory[i + startIndex] = GlobalMemory[i];
    }
}




// Opdel flash bank 0-32 / 3 

// Lav en mapping til arrays af structs


</declaration>
		<location id="id3" x="-527" y="-459">
		</location>
		<location id="id4" x="-527" y="-629">
		</location>
		<init ref="id4"/>
		<transition>
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="select" x="-467" y="-501">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-467" y="-467">PmpWriteMemory[s][e]?</label>
			<label kind="assignment" x="-467" y="-450">writeMemory(s,e)</label>
			<nail x="-476" y="-476"/>
			<nail x="-476" y="-442"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="select" x="-782" y="-501">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-782" y="-467">PmpReadMemory[s][e]?</label>
			<label kind="assignment" x="-782" y="-450">readMemory(s,e)</label>
			<nail x="-578" y="-476"/>
			<nail x="-578" y="-442"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-637" y="-586">PowerOnBC?</label>
			<label kind="assignment" x="-637" y="-569">initializeMemory()</label>
		</transition>
	</template>
	<template>
		<name>SRAMController</name>
		<declaration>int startIndex, endIndex;
int scrambleKey;
bool scrambled;
const int SRAMSize = MemoryMaxIndex / 20;
int[0,SRAMSize-1] dictionaryIndex = 0;

typedef struct{
    int startIndex;
    int endIndex;
    bool isScrambled;
    int key;
} sram_entry_t;

sram_entry_t sramContents[SRAMSize];

void scramble(){
    scrambled = true;
}

void updateSRAM(int s, int e){
    sramContents[dictionaryIndex].startIndex = s;
    sramContents[dictionaryIndex].endIndex = e;
    sramContents[dictionaryIndex].isScrambled = true;
    dictionaryIndex = (dictionaryIndex + 1) % SRAMSize; 
    
}

bool existsInSRAM(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; SRAMSize; i++){
        if(sramContents[i].startIndex == startIndex &amp;&amp; sramContents[i].endIndex == endIndex){
            return true;
        }
    }
    return false;
}


</declaration>
		<location id="id5" x="144" y="178">
		</location>
		<location id="id6" x="-34" y="0">
		</location>
		<location id="id7" x="246" y="-110">
			<committed/>
		</location>
		<location id="id8" x="-170" y="0">
			<committed/>
		</location>
		<location id="id9" x="-68" y="-212">
		</location>
		<location id="id10" x="34" y="-212">
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="212" y="110">WriteSRAMReturn!</label>
			<nail x="221" y="76"/>
			<nail x="153" y="34"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id5"/>
			<label kind="select" x="-51" y="187">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-51" y="221">WriteSRAM[s][e]?</label>
			<label kind="assignment" x="-51" y="238">updateSRAM(s, e)</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="42" y="-170">CheckSRAMReturn!</label>
			<nail x="34" y="-127"/>
			<nail x="-34" y="-76"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-127" y="-272">ReadSRAM[startIndex][endIndex]!</label>
			<label kind="assignment" x="-127" y="-255">startIndex = 0, endIndex = 0</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="guard" x="-221" y="-76">scrambleKey == 0</label>
			<label kind="synchronisation" x="-221" y="-59">RequestScrambleKey!</label>
			<nail x="-102" y="-34"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-314" y="25">ReturnScrambleKey?</label>
			<label kind="assignment" x="-314" y="42">scrambleKey = GlobalSecretKey,
GlobalSecretKey = 0</label>
			<nail x="-102" y="34"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="59" y="-102">NotInSRAM!</label>
			<nail x="212" y="-110"/>
			<nail x="-17" y="-17"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="select" x="187" y="-68">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="204" y="-34">!existsInSRAM(s,e)</label>
			<label kind="synchronisation" x="204" y="-17">CheckSRAM[s][e]?</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id9"/>
			<label kind="select" x="-272" y="-195">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-204" y="-161">existsInSRAM(s,e)</label>
			<label kind="synchronisation" x="-196" y="-144">CheckSRAM[s][e]?</label>
			<label kind="assignment" x="-256" y="-127">startIndex = s, endIndex = e</label>
			<nail x="-68" y="-68"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-93" y="85">RaiseExceptionBC?</label>
			<label kind="assignment" x="-68" y="102">scramble()</label>
			<nail x="0" y="68"/>
			<nail x="-68" y="68"/>
		</transition>
	</template>
	<template>
		<name>MemoryHandling</name>
		<declaration>int s = -1;
int e = -1;</declaration>
		<location id="id11" x="-11841" y="-12052">
		</location>
		<location id="id12" x="-11840" y="-12163">
		</location>
		<location id="id13" x="-12002" y="-12256">
		</location>
		<location id="id14" x="-12002" y="-12375">
		</location>
		<location id="id15" x="-12172" y="-12315">
		</location>
		<location id="id16" x="-12316" y="-12316">
		</location>
		<location id="id17" x="-12580" y="-12316">
		</location>
		<location id="id18" x="-12044" y="-12053">
		</location>
		<location id="id19" x="-12223" y="-12053">
		</location>
		<location id="id20" x="-12750" y="-12316">
		</location>
		<location id="id21" x="-12877" y="-12316">
		</location>
		<init ref="id17"/>
		<transition>
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-12852" y="-12350">WriteSRAM!</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-12716" y="-12342">WriteMemory?</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-12189" y="-12078">WriteSRAMReturn?</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-11993" y="-12078">WriteSRAM[s][e]!</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-12418" y="-12078">ReadMemoryReturn!</label>
			<label kind="assignment" x="-12418" y="-12053">s = -1,
e = -1</label>
			<nail x="-12478" y="-12052"/>
			<nail x="-12580" y="-12257"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-12342" y="-12503">ReadMemoryReturn!</label>
			<label kind="assignment" x="-12342" y="-12478">s = -1,
e = -1</label>
			<nail x="-12002" y="-12477"/>
			<nail x="-12478" y="-12477"/>
			<nail x="-12580" y="-12376"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-11832" y="-12120">FlashReadReturn?</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-11976" y="-12188">FlashRead[s][e]!</label>
			<nail x="-12002" y="-12163"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-12146" y="-12282">NotInSRAM?</label>
			<nail x="-12172" y="-12256"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-12172" y="-12400">CheckSRAMReturn?</label>
			<nail x="-12172" y="-12375"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-12299" y="-12342">CheckSRAM[s][e]!</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="select" x="-12563" y="-12376">startIndex: int[0, MemoryMaxIndex - 1],
endIndex: int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-12563" y="-12342">ReadMemory[startIndex][endIndex]?</label>
			<label kind="assignment" x="-12563" y="-12316">s = startIndex,
e = endIndex</label>
		</transition>
	</template>
	<template>
		<name>SRAM</name>
		<declaration>const int SRAMsize = MemoryMaxIndex / 20;
rom_exts_manifests_t manifests;
int[0, NumberOfKeysInWhitelist] pubKeyWhitelist[NumberOfKeysInWhitelist];
int SRAM[SRAMsize];

//Is not called atm 16-04-2021
void readSRAM(int startIndex, int endIndex){
    if(startIndex &gt;= 0 &amp;&amp; endIndex &lt;= 19){
        //Something from ROM
        if (startIndex == 13 &amp;&amp; endIndex == 13){ // public key id whitelist used for public key verification.
            GlobalPublicKeyIdWhitelist = pubKeyWhitelist; //Should be changed to an actual transference of an array from flash into the global array
            GlobalMemoryIsScrambled = true;
        }
    }
    if(startIndex &gt;= 20 &amp;&amp; endIndex &lt;= 29){
        //Something from Flash Info
    }
    if(startIndex &gt;= 30 &amp;&amp; endIndex &lt;= 64){
        //Something from Flash Bank 0
        if(startIndex == 30 &amp;&amp; endIndex == 41){
            GlobalManifest = manifests.rom_exts_mfs[0];
            GlobalMemoryIsScrambled = true;
        }

    }
    if(startIndex &gt;= 65 &amp;&amp; endIndex &lt;= 99){
        //Something from Flash Bank 1
        if(startIndex == 65 &amp;&amp; endIndex == 76){
            GlobalManifest = manifests.rom_exts_mfs[1];
        }
    }
    else{
        if (startIndex == 100){
            GlobalManifest = manifests.rom_exts_mfs[2];
        }
        else if (startIndex == 135){
            GlobalManifest = manifests.rom_exts_mfs[3];
        }
        //You fucked up
    }
}</declaration>
		<location id="id22" x="-1657" y="-1496">
		</location>
		<init ref="id22"/>
		<transition>
			<source ref="id22"/>
			<target ref="id22"/>
			<label kind="select" x="-1674" y="-1598">s: int[0, MemoryMaxIndex-1],
e: int[0, MemoryMaxIndex-1]</label>
			<label kind="synchronisation" x="-1674" y="-1564">ReadSRAM[s][e]?</label>
			<nail x="-1538" y="-1547"/>
			<nail x="-1538" y="-1454"/>
		</transition>
	</template>
	<template>
		<name>ROMStage</name>
		<declaration>boot_policy_t bootPolicy;
rom_exts_manifests_t romExtsManifests;
rom_ext_manifest_t currentManifest;
int loopIndex = 0;
pub_key_t key;
//int entryPoint;


//void readPublicKey(){
    //Read from global??
  //  key = currentManifest.pub_signature_key;
//}

void pmpUnlockRomExt(){
    PmpRegions[0].startAddress = currentManifest.entryPoint; 
    PmpRegions[0].endAddress = currentManifest.entryPoint + 4;
    PmpRegions[0].locked = true;
    PmpRegions[0].read = true;
    PmpRegions[0].execute = true;
    PmpRegions[0].write = false;    
}

void clearManifest(){
    int i;
    currentManifest.identifier = 0;
    currentManifest.entryPoint = 0; 
    currentManifest.image_code = 0;
    currentManifest.signature = 0;
}
</declaration>
		<location id="id23" x="-85" y="17">
			<name x="-76" y="-8">CheckingKey</name>
		</location>
		<location id="id24" x="238" y="-561">
			<name x="255" y="-578">Rom_Ext_terminated</name>
		</location>
		<location id="id25" x="238" y="-476">
		</location>
		<location id="id26" x="238" y="-255">
			<name x="246" y="-272">CheckedSignature</name>
		</location>
		<location id="id27" x="238" y="-187">
			<name x="263" y="-195">CheckingSignature</name>
		</location>
		<location id="id28" x="-85" y="-357">
		</location>
		<location id="id29" x="-85" y="-561">
			<name x="-68" y="-578">Boot_Failed</name>
		</location>
		<location id="id30" x="-85" y="-459">
			<name x="-68" y="-484">StartOfLoop</name>
		</location>
		<location id="id31" x="-459" y="-629">
		</location>
		<location id="id32" x="-85" y="-629">
		</location>
		<location id="id33" x="238" y="-629">
		</location>
		<location id="id34" x="-459" y="-552">
		</location>
		<location id="id35" x="-459" y="-459">
		</location>
		<location id="id36" x="-85" y="-272">
			<name x="-68" y="-297">IdentifierChecked</name>
		</location>
		<location id="id37" x="76" y="-187">
			<name x="85" y="-212">SignatureCheck</name>
		</location>
		<location id="id38" x="238" y="-357">
			<name x="255" y="-374">ReadyToRunROMExt</name>
		</location>
		<location id="id39" x="-85" y="-187">
		</location>
		<location id="id40" x="-85" y="-85">
		</location>
		<init ref="id33"/>
		<transition>
			<source ref="id23"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="-476" y="-25">PubKeyNotValidBC?</label>
			<label kind="assignment" x="-476" y="-8">loopIndex++</label>
			<nail x="-493" y="17"/>
			<nail x="-493" y="-425"/>
			<nail x="-348" y="-425"/>
			<nail x="-348" y="-442"/>
			<nail x="-110" y="-442"/>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="93" y="-8">PubKeyValidBC?</label>
			<nail x="76" y="17"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="-272" y="-59">CheckPublicKeyValidCallBC!</label>
			<label kind="assignment" x="-238" y="-42">GlobalPublicKey = key</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id40"/>
			<label kind="synchronisation" x="-246" y="-161">ReadPublicKeyReturn?</label>
			<label kind="assignment" x="-246" y="-144">key = GlobalPublicKey,
ClearGlobalPublicKey()</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-221" y="-246">ReadPublicKeyCall!</label>
			<label kind="assignment" x="-306" y="-229">GlobalManifest = currentManifest</label>
			<nail x="-85" y="-212"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="-59" y="-425">CheckRomExtManifestNotValid?</label>
			<label kind="assignment" x="-59" y="-408">loopIndex++</label>
			<nail x="-68" y="-408"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-76" y="-323">CheckRomExtManifestValid?</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="246" y="-527">FinalJumpReturn?</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="255" y="-433">FinalJumpCall!</label>
			<label kind="assignment" x="255" y="-416">GlobalManifest = currentManifest</label>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="102" y="-170">CheckSignatureBC!</label>
			<label kind="assignment" x="102" y="-153">GlobalSignature = currentManifest.signature,
GlobalImageCode = currentManifest.image_code</label>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="-399" y="-527">REMTTReturn?</label>
			<label kind="assignment" x="-399" y="-510">romExtsManifests = GlobalRomExtsManifests,
clearGlobalRomExtsManifests()</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-544" y="-510">REMTTCall!</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id38"/>
			<label kind="assignment" x="255" y="-314">pmpUnlockRomExt()</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="255" y="-229">SignatureValidBC?</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="51" y="-255">SignatureNotValidBC?</label>
			<label kind="assignment" x="110" y="-272">loopIndex++</label>
			<nail x="221" y="-204"/>
			<nail x="221" y="-229"/>
			<nail x="204" y="-238"/>
			<nail x="195" y="-255"/>
			<nail x="204" y="-272"/>
			<nail x="221" y="-280"/>
			<nail x="221" y="-331"/>
			<nail x="204" y="-340"/>
			<nail x="195" y="-357"/>
			<nail x="204" y="-374"/>
			<nail x="221" y="-382"/>
			<nail x="221" y="-442"/>
			<nail x="212" y="-450"/>
			<nail x="212" y="-450"/>
			<nail x="204" y="-459"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id28"/>
			<label kind="guard" x="-323" y="-425">loopIndex &lt; NumberOfFlashBanks</label>
			<label kind="synchronisation" x="-272" y="-408">CheckRomExtManifestCall!</label>
			<label kind="assignment" x="-484" y="-391">currentManifest = romExtsManifests.rom_exts_mfs[loopIndex],
GlobalManifest = currentManifest</label>
			<nail x="-102" y="-408"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id29"/>
			<label kind="guard" x="-76" y="-518">loopIndex &gt;= NumberOfFlashBanks</label>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-442" y="-603">ReadBootPolicyReturn?</label>
			<label kind="assignment" x="-442" y="-586">bootPolicy = GlobalBootPolicy</label>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-357" y="-654">ReadBootPolicyCall!</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="42" y="-654">StartRomStage?</label>
		</transition>
	</template>
	<template>
		<name>ReadPublicKey</name>
		<declaration>rom_ext_manifest_t manifest;</declaration>
		<location id="id41" x="-688" y="-391">
		</location>
		<location id="id42" x="-212" y="-391">
		</location>
		<init ref="id41"/>
		<transition>
			<source ref="id42"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-518" y="-297">ReadPublicKeyReturn!</label>
			<nail x="-212" y="-272"/>
			<nail x="-688" y="-272"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-646" y="-450">ReadPublicKeyCall?</label>
			<label kind="assignment" x="-646" y="-433">GlobalPublicKey = GlobalManifest.publicKey,
ClearGlobalManifest()</label>
			<nail x="-229" y="-391"/>
		</transition>
	</template>
	<template>
		<name>CheckRomExtManifest</name>
		<declaration>rom_ext_manifest_t manifest;

bool checkRomExtManifest(){
    return manifest.identifier == 1;
}

void clearManifest(){
    manifest.identifier = 0;
    manifest.signature = 0;
    manifest.image_code = 0;
    manifest.entryPoint = 0;
}</declaration>
		<location id="id43" x="-51" y="-51">
			<name x="-34" y="-68">Called</name>
		</location>
		<location id="id44" x="-289" y="-51">
			<name x="-331" y="-68">Idle</name>
		</location>
		<init ref="id44"/>
		<transition>
			<source ref="id43"/>
			<target ref="id44"/>
			<label kind="guard" x="-289" y="0">!checkRomExtManifest()</label>
			<label kind="synchronisation" x="-289" y="17">CheckRomExtManifestNotValid!</label>
			<nail x="-51" y="0"/>
			<nail x="-289" y="0"/>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id44"/>
			<label kind="guard" x="-280" y="-136">checkRomExtManifest()</label>
			<label kind="synchronisation" x="-280" y="-119">CheckRomExtManifestValid!</label>
			<nail x="-51" y="-102"/>
			<nail x="-289" y="-102"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-271" y="-68">CheckRomExtManifestCall?</label>
			<label kind="assignment" x="-271" y="-51">manifest = GlobalManifest,
ClearGlobalManifest()</label>
		</transition>
	</template>
	<template>
		<name>ReadBootPolicy</name>
		<declaration>void readBootPolicy(){
    //GlobalBootPolicy.identifier = GlobalMemory[0];
    
    GlobalBootPolicy.rom_ext_slot[0] = 30; // Address of flash bank 0.
    if (NumberOfFlashBanks &gt;= 2){
        GlobalBootPolicy.rom_ext_slot[1] = 65; // Address of flash bank 1.
    }
    if (NumberOfFlashBanks == 4){
        GlobalBootPolicy.rom_ext_slot[2] = 100; // Address of flash bank 2.
        GlobalBootPolicy.rom_ext_slot[3] = 135; // Address of flash bank 3.
    }
    //GlobalBootPolicy.fail_function_address = GlobalMemory[1];
    //GlobalBootPolicy.rom_ext_failure_function_address = GlobalMemory[2];
}</declaration>
		<location id="id45" x="-178" y="0">
			<name x="-161" y="-8">Reading</name>
		</location>
		<location id="id46" x="-374" y="-153">
			<name x="-391" y="-196">Called</name>
		</location>
		<location id="id47" x="-374" y="0">
			<name x="-416" y="-8">Idle</name>
		</location>
		<location id="id48" x="-178" y="-153">
		</location>
		<init ref="id47"/>
		<transition>
			<source ref="id48"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-170" y="-93">ReadMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-340" y="17">ReadBootPolicyReturn!</label>
			<label kind="assignment" x="-340" y="0">readBootPolicy()</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="-348" y="-178">ReadMemory[21][29]!</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="-510" y="-85">ReadBootPolicyCall?</label>
		</transition>
	</template>
	<template>
		<name>Zeno</name>
		<location id="id49" x="-17" y="-17">
			<urgent/>
		</location>
		<init ref="id49"/>
	</template>
	<template>
		<name>RomExt</name>
		<parameter>const int[0, NumberOfFlashBanks - 1] id</parameter>
		<location id="id50" x="-153" y="-289">
		</location>
		<location id="id51" x="-153" y="-153">
		</location>
		<location id="id52" x="-357" y="-153">
		</location>
		<init ref="id52"/>
		<transition>
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-153" y="-238">AdvanceKMState!</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-339" y="-170">RomExtStart[38 + 35 * id]?</label>
		</transition>
	</template>
	<template>
		<name>rom_ext_manifests_to_try</name>
		<declaration>boot_policy_t bootPolicy;
rom_ext_manifest_t manifest;
int loopIndex = 0;
int startReadIndex, endReadIndex;

/*
void makeManifest(){
    rom_ext_manifest_t manifest;
    // The fields are filled out pretty randomly -.-
    int i;
    manifest.identifier = GlobalMemory[0];
    manifest.entryPoint = GlobalMemory[3]; //34, 69
    manifest.signature = GlobalMemory[2];
    for(i = 0; i &lt; 10; i++){
        manifest.pub_signature_key.key[i] = GlobalMemory[3];
        manifest.image_code[i] = GlobalMemory[4];
    }
    manifests[loopIndex] = manifest;
}
*/

//ReadMemory[bootPolicy.rom_ext_slot[loopIndex] + (35 * loopIndex)][bootPolicy.rom_ext_slot[loopIndex] + 11 + (35 * loopIndex)]!
void setReadIndices(){
    if(loopIndex &lt; NumberOfFlashBanks){
        startReadIndex = bootPolicy.rom_ext_slot[loopIndex];
        endReadIndex = bootPolicy.rom_ext_slot[loopIndex] + 11;
    }
}

void makeManifest(){
    GlobalManifest = manifest;
}


void returnManifests(){
    int i;
    GlobalRomExtsManifests.size = NumberOfFlashBanks;
    GlobalRomExtsManifests.rom_exts_mfs[0] = manifest;
}


/*
    int identifier;
    int entryPoint; //address in memory
    int signature;
    pub_key_t pub_signature_key;
    int image_code[10];
*/
</declaration>
		<location id="id53" x="799" y="-221">
			<name x="789" y="-255">GeneratingManifest</name>
		</location>
		<location id="id54" x="629" y="-221">
			<name x="586" y="-229">Idle</name>
		</location>
		<init ref="id54"/>
		<transition>
			<source ref="id53"/>
			<target ref="id54"/>
			<label kind="select" x="731" y="-170">i : int[1,2],
j : int[0,1],
k : int[0,1],
l : int[0,1]</label>
			<label kind="synchronisation" x="731" y="-93">REMTTReturn!</label>
			<label kind="assignment" x="731" y="-76">manifest.image_code = i,
manifest.signature = j,
manifest.publicKey.exponent = k,
manifest.publicKey.modulus = l,
returnManifests()</label>
			<nail x="714" y="-170"/>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id53"/>
			<label kind="select" x="620" y="-382">i : int[0,2]</label>
			<label kind="synchronisation" x="620" y="-365">REMTTCall?</label>
			<label kind="assignment" x="620" y="-348">bootPolicy = GlobalBootPolicy,
clearGlobalBootPolicy(),
manifest.identifier = i,
manifest.entryPoint = 38</label>
			<nail x="714" y="-272"/>
		</transition>
	</template>
	<template>
		<name>rom_ext_manifests_to_try_standard</name>
		<declaration>boot_policy_t bootPolicy;
rom_ext_manifest_t manifests[NumberOfFlashBanks];
int loopIndex = 0;
int startReadIndex, endReadIndex;

/*
void makeManifest(){
    rom_ext_manifest_t manifest;
    // The fields are filled out pretty randomly -.-
    int i;
    manifest.identifier = GlobalMemory[0];
    manifest.entryPoint = GlobalMemory[3]; //34, 69
    manifest.signature = GlobalMemory[2];
    for(i = 0; i &lt; 10; i++){
        manifest.pub_signature_key.key[i] = GlobalMemory[3];
        manifest.image_code[i] = GlobalMemory[4];
    }
    manifests[loopIndex] = manifest;
}
*/

//ReadMemory[bootPolicy.rom_ext_slot[loopIndex] + (35 * loopIndex)][bootPolicy.rom_ext_slot[loopIndex] + 11 + (35 * loopIndex)]!
void setReadIndices(){
    if(loopIndex &lt; NumberOfFlashBanks){
        startReadIndex = bootPolicy.rom_ext_slot[loopIndex];
        endReadIndex = bootPolicy.rom_ext_slot[loopIndex] + 11;
    }
}

void makeManifest(){
    manifests[loopIndex] = GlobalManifest;
}


void returnManifests(){
    int i;
    GlobalRomExtsManifests.size = NumberOfFlashBanks;
    GlobalRomExtsManifests.rom_exts_mfs = manifests;
}


/*
    int identifier;
    int entryPoint; //address in memory
    int signature;
    pub_key_t pub_signature_key;
    int image_code[10];
*/
</declaration>
		<location id="id55" x="731" y="-331">
		</location>
		<location id="id56" x="612" y="-289">
		</location>
		<location id="id57" x="510" y="-289">
		</location>
		<location id="id58" x="731" y="-246">
		</location>
		<init ref="id57"/>
		<transition>
			<source ref="id58"/>
			<target ref="id56"/>
			<label kind="assignment" x="612" y="-229">makeManifest(),
ClearGlobalManifest(),
loopIndex++,
setReadIndices()</label>
			<nail x="663" y="-238"/>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id57"/>
			<label kind="guard" x="365" y="-238">loopIndex &gt;= NumberOfFlashBanks</label>
			<label kind="synchronisation" x="365" y="-221">REMTTReturn!</label>
			<label kind="assignment" x="365" y="-204">returnManifests()</label>
			<nail x="561" y="-238"/>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="739" y="-306">CheckSRAMReturn?</label>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id55"/>
			<label kind="guard" x="620" y="-365">loopIndex &lt; NumberOfFlashBanks</label>
			<label kind="synchronisation" x="620" y="-382">CheckSRAM[startReadIndex][endReadIndex]!</label>
			<nail x="663" y="-340"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id56"/>
			<label kind="synchronisation" x="399" y="-399">REMTTCall?</label>
			<label kind="assignment" x="399" y="-382">bootPolicy = GlobalBootPolicy,
clearGlobalBootPolicy(),
setReadIndices()</label>
			<nail x="561" y="-340"/>
		</transition>
	</template>
	<template>
		<name>final_jump_to_rom_ext</name>
		<declaration>rom_ext_manifest_t currentManifest;</declaration>
		<location id="id59" x="-408" y="-391">
		</location>
		<location id="id60" x="-255" y="-391">
		</location>
		<location id="id61" x="-59" y="-391">
			<name x="-42" y="-391">ROM_ext_running</name>
		</location>
		<location id="id62" x="-59" y="-289">
		</location>
		<location id="id63" x="-595" y="-289">
		</location>
		<location id="id64" x="-850" y="-289">
		</location>
		<init ref="id64"/>
		<transition>
			<source ref="id60"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="-382" y="-416">FinalJumpReturn!</label>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-221" y="-416">Rom_Ext_Fail?</label>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-51" y="-348">RomExtStart[currentManifest.entryPoint]!</label>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-578" y="-314">TryExecuteMemory[currentManifest.entryPoint][currentManifest.entryPoint + 4]!</label>
		</transition>
		<transition>
			<source ref="id64"/>
			<target ref="id63"/>
			<label kind="synchronisation" x="-833" y="-348">FinalJumpCall?</label>
			<label kind="assignment" x="-833" y="-331">currentManifest = GlobalManifest,
ClearGlobalManifest()</label>
		</transition>
	</template>
	<template>
		<name>CheckPubKeyValid</name>
		<declaration>pub_key_t publicKey;
int[0,NumberOfKeysInWhitelist] pubKeyIdList[NumberOfKeysInWhitelist];
int[0,1] currentPubKeyId;

bool checkPublicKey(){
    int i;

    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++)    
        if (pubKeyIdList[i] == currentPubKeyId)
                return true;
    return false;
}

void calculateKeyId(){
 if(publicKey.exponent == 1 &amp;&amp; publicKey.modulus == 1)
        currentPubKeyId = 1;
    else
        currentPubKeyId = 0;
}</declaration>
		<location id="id65" x="246" y="-289">
		</location>
		<location id="id66" x="-68" y="-289">
		</location>
		<location id="id67" x="-272" y="-289">
		</location>
		<location id="id68" x="-527" y="-289">
		</location>
		<init ref="id68"/>
		<transition>
			<source ref="id66"/>
			<target ref="id65"/>
			<label kind="synchronisation" x="-34" y="-314">ReadMemoryReturn?</label>
			<label kind="assignment" x="-51" y="-289">pubKeyIdList = GlobalPublicKeyIdWhitelist,
ClearGlobalPubKeyWhitelist(),
calculateKeyId()</label>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id66"/>
			<label kind="synchronisation" x="-246" y="-314">ReadMemory[13][13]!</label>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id68"/>
			<label kind="guard" x="-187" y="-382">!checkPublicKey()</label>
			<label kind="synchronisation" x="-187" y="-365">PubKeyNotValidBC!</label>
			<nail x="246" y="-340"/>
			<nail x="-527" y="-340"/>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id68"/>
			<label kind="guard" x="-170" y="-187">checkPublicKey()</label>
			<label kind="synchronisation" x="-170" y="-170">PubKeyValidBC!</label>
			<nail x="246" y="-204"/>
			<nail x="-527" y="-204"/>
		</transition>
		<transition>
			<source ref="id68"/>
			<target ref="id67"/>
			<label kind="synchronisation" x="-493" y="-314">CheckPublicKeyValidCallBC?</label>
			<label kind="assignment" x="-493" y="-289">publicKey = GlobalPublicKey,
ClearGlobalPublicKey()</label>
		</transition>
	</template>
	<template>
		<name>RSAModule</name>
		<declaration>int signature;
int image_code;
pub_key_t key;

bool checkSignature(){
    return signature == image_code &amp;&amp; image_code == 1;
}

void clear(){
    key.exponent = 0;
    key.modulus = 0;
    signature = 0;
    image_code = 0;  
}</declaration>
		<location id="id69" x="-578" y="-476">
		</location>
		<location id="id70" x="-926" y="-476">
		</location>
		<location id="id71" x="-357" y="-476">
		</location>
		<location id="id72" x="-697" y="-476">
		</location>
		<init ref="id70"/>
		<transition>
			<source ref="id69"/>
			<target ref="id71"/>
			<label kind="synchronisation" x="-561" y="-493">HMACReturn?</label>
			<label kind="assignment" x="-561" y="-459">GlobalImageCode = 0</label>
		</transition>
		<transition>
			<source ref="id72"/>
			<target ref="id69"/>
			<label kind="synchronisation" x="-679" y="-493">HMACCalled!</label>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id72"/>
			<label kind="synchronisation" x="-884" y="-425">CheckSignatureBC?</label>
			<label kind="assignment" x="-884" y="-476">signature = GlobalSignature,
image_code = GlobalImageCode,
key = GlobalPublicKey</label>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id70"/>
			<label kind="guard" x="-841" y="-586">!checkSignature()</label>
			<label kind="synchronisation" x="-841" y="-569">SignatureNotValidBC!</label>
			<label kind="assignment" x="-841" y="-552">clear()</label>
			<nail x="-357" y="-527"/>
			<nail x="-926" y="-527"/>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id70"/>
			<label kind="guard" x="-858" y="-348">checkSignature()</label>
			<label kind="synchronisation" x="-858" y="-331">SignatureValidBC!</label>
			<label kind="assignment" x="-858" y="-314">clear()</label>
			<nail x="-357" y="-348"/>
			<nail x="-926" y="-348"/>
		</transition>
	</template>
	<template>
		<name>ValidityCheckObserver</name>
		<declaration>//Fix guards in accordance to new key make up</declaration>
		<location id="id73" x="391" y="-51">
			<name x="381" y="-85">Success</name>
		</location>
		<location id="id74" x="187" y="-51">
		</location>
		<location id="id75" x="-51" y="-51">
		</location>
		<location id="id76" x="-289" y="-51">
		</location>
		<location id="id77" x="-51" y="51">
			<committed/>
		</location>
		<init ref="id76"/>
		<transition>
			<source ref="id77"/>
			<target ref="id76"/>
			<nail x="-289" y="51"/>
		</transition>
		<transition>
			<source ref="id74"/>
			<target ref="id77"/>
			<label kind="guard" x="-25" y="8">GlobalSignature != 33</label>
			<label kind="synchronisation" x="-25" y="25">SignatureNotValidBC?</label>
			<nail x="187" y="51"/>
		</transition>
		<transition>
			<source ref="id75"/>
			<target ref="id77"/>
			<label kind="synchronisation" x="-229" y="0">PubKeyNotValidBC?</label>
		</transition>
		<transition>
			<source ref="id74"/>
			<target ref="id73"/>
			<label kind="guard" x="205" y="-85">GlobalSignature == 33</label>
			<label kind="synchronisation" x="204" y="-102">SignatureValidBC?</label>
		</transition>
		<transition>
			<source ref="id75"/>
			<target ref="id74"/>
			<label kind="synchronisation" x="-25" y="-76">PubKeyValidBC?</label>
		</transition>
		<transition>
			<source ref="id76"/>
			<target ref="id75"/>
			<label kind="select" x="-263" y="-127">e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-263" y="-110">e != 0</label>
			<label kind="synchronisation" x="-263" y="-93">RomExtValidBC[e]?</label>
		</transition>
	</template>
	<template>
		<name>PmpModuleOld</name>
		<declaration>int start, end;

void initializePmp(){
    PmpRegions[15].startAddress = 0;
    PmpRegions[15].endAddress = MemoryMaxIndex;
    PmpRegions[15].write = false;
    PmpRegions[15].read = true;
    PmpRegions[15].execute = false;
    PmpRegions[15].locked = true;
}
bool canRead(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].read)
                return true;
    return false;
}

bool canWrite(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].write)
                return true;
    return false;
}

bool canExecute(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].execute)
                return true;
    return false;
}</declaration>
		<location id="id78" x="-204" y="-340">
		</location>
		<location id="id79" x="-136" y="-510">
		</location>
		<location id="id80" x="-34" y="-340">
			<committed/>
		</location>
		<location id="id81" x="-382" y="-340">
			<committed/>
		</location>
		<init ref="id79"/>
		<transition>
			<source ref="id81"/>
			<target ref="id78"/>
			<label kind="synchronisation" x="-493" y="-297">PmpReadMemory[start][end]!</label>
			<label kind="assignment" x="-493" y="-280">start = 0,
end = 0</label>
			<nail x="-382" y="-306"/>
			<nail x="-238" y="-306"/>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id78"/>
			<label kind="synchronisation" x="-51" y="-297">PmpWriteMemory[start][end]!</label>
			<label kind="assignment" x="-51" y="-280">start = 0,
end = 0</label>
			<nail x="-34" y="-306"/>
			<nail x="-170" y="-306"/>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id78"/>
			<label kind="select" x="-272" y="-238">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-272" y="-204">canExecute(s,e)</label>
			<label kind="synchronisation" x="-272" y="-187">TryExecuteMemory[s][e]?</label>
			<nail x="-221" y="-272"/>
			<nail x="-187" y="-272"/>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id80"/>
			<label kind="select" x="-17" y="-450">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-17" y="-416">canWrite(s,e)</label>
			<label kind="synchronisation" x="-17" y="-399">TryWriteMemory[s][e]?</label>
			<label kind="assignment" x="-17" y="-382">start = s,
end = e</label>
			<nail x="-178" y="-374"/>
			<nail x="-34" y="-374"/>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id81"/>
			<label kind="select" x="-484" y="-459">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-484" y="-425">canRead(s, e)</label>
			<label kind="synchronisation" x="-484" y="-408">TryReadMemory[s][e]?</label>
			<label kind="assignment" x="-484" y="-391">start = s,
end = e</label>
			<nail x="-238" y="-374"/>
			<nail x="-382" y="-374"/>
		</transition>
		<transition>
			<source ref="id79"/>
			<target ref="id78"/>
			<label kind="synchronisation" x="-238" y="-501">PowerOnBC?</label>
			<label kind="assignment" x="-238" y="-484">initializePmp()</label>
			<nail x="-238" y="-510"/>
			<nail x="-238" y="-442"/>
			<nail x="-136" y="-442"/>
			<nail x="-136" y="-408"/>
			<nail x="-204" y="-408"/>
		</transition>
	</template>
	<template>
		<name>PmpModule</name>
		<declaration>int start, end;

void initializePmp(){
    PmpRegions[15].startAddress = 0;
    PmpRegions[15].endAddress = MemoryMaxIndex;
    PmpRegions[15].write = false;
    PmpRegions[15].read = true;
    PmpRegions[15].execute = false;
    PmpRegions[15].locked = true;
}
bool canRead(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].read)
                return true;
    return false;
}

bool canWrite(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].write)
                return true;
    return false;
}

bool canExecute(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].execute)
                return true;
    return false;
}</declaration>
		<location id="id82" x="-204" y="-340">
			<name x="-212" y="-314">Idle</name>
		</location>
		<location id="id83" x="-238" y="-493">
			<name x="-248" y="-527">Initial</name>
		</location>
		<location id="id84" x="136" y="-340">
			<name x="153" y="-357">Writing_Memory</name>
			<committed/>
		</location>
		<location id="id85" x="-544" y="-340">
			<name x="-663" y="-374">Reading_Memory</name>
			<committed/>
		</location>
		<location id="id86" x="-85" y="-153">
			<name x="-68" y="-161">CannotExecute</name>
			<committed/>
		</location>
		<init ref="id83"/>
		<transition>
			<source ref="id86"/>
			<target ref="id82"/>
			<label kind="synchronisation" x="-68" y="-187">RaiseExceptionBC!</label>
			<nail x="-68" y="-170"/>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id86"/>
			<label kind="select" x="-212" y="-136">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-212" y="-102">!canExecute(s,e)</label>
			<label kind="synchronisation" x="-212" y="-85">TryExecuteMemory[s][e]?</label>
			<nail x="-102" y="-136"/>
		</transition>
		<transition>
			<source ref="id84"/>
			<target ref="id82"/>
			<label kind="guard" x="-35" y="-416">!canWrite(start,end)</label>
			<label kind="synchronisation" x="-34" y="-399">RaiseExceptionBC!</label>
			<label kind="assignment" x="-34" y="-382">start = 0,
end = 0</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id82"/>
			<label kind="guard" x="-433" y="-416">!canRead(start,end)</label>
			<label kind="synchronisation" x="-433" y="-399">RaiseExceptionBC!</label>
			<label kind="assignment" x="-433" y="-382">start = 0,
end = 0</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id82"/>
			<label kind="guard" x="-510" y="-280">canRead(start, end)</label>
			<label kind="synchronisation" x="-510" y="-263">PmpReadMemory[start][end]!</label>
			<label kind="assignment" x="-510" y="-246">start = 0,
end = 0</label>
			<nail x="-544" y="-204"/>
			<nail x="-340" y="-204"/>
		</transition>
		<transition>
			<source ref="id84"/>
			<target ref="id82"/>
			<label kind="guard" x="-50" y="-238">canWrite(start,end)</label>
			<label kind="synchronisation" x="-51" y="-297">PmpWriteMemory[start][end]!</label>
			<label kind="assignment" x="-51" y="-280">start = 0,
end = 0</label>
			<nail x="136" y="-204"/>
			<nail x="-68" y="-204"/>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id82"/>
			<label kind="select" x="-450" y="-127">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-450" y="-93">canExecute(s,e)</label>
			<label kind="synchronisation" x="-450" y="-76">TryExecuteMemory[s][e]?</label>
			<nail x="-340" y="-170"/>
			<nail x="-306" y="-136"/>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id84"/>
			<label kind="select" x="0" y="-578">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="0" y="-535">TryWriteMemory[s][e]?</label>
			<label kind="assignment" x="0" y="-518">start = s,
end = e</label>
			<nail x="-68" y="-476"/>
			<nail x="136" y="-476"/>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id85"/>
			<label kind="select" x="-510" y="-578">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-510" y="-544">TryReadMemory[s][e]?</label>
			<label kind="assignment" x="-510" y="-527">start = s,
end = e</label>
			<nail x="-340" y="-476"/>
			<nail x="-544" y="-476"/>
		</transition>
		<transition>
			<source ref="id83"/>
			<target ref="id82"/>
			<label kind="synchronisation" x="-229" y="-484">PowerOnBC?</label>
			<label kind="assignment" x="-229" y="-467">initializePmp()</label>
			<nail x="-238" y="-467"/>
			<nail x="-238" y="-459"/>
			<nail x="-238" y="-442"/>
			<nail x="-204" y="-442"/>
			<nail x="-204" y="-408"/>
		</transition>
	</template>
	<template>
		<name>FlashController</name>
		<declaration>int startIndex, endIndex;

void unscramble(){
    GlobalMemoryIsScrambled = false;
}

</declaration>
		<location id="id87" x="51" y="-17">
		</location>
		<location id="id88" x="51" y="-85">
		</location>
		<location id="id89" x="-119" y="-51">
			<name x="-129" y="-85">Idle</name>
		</location>
		<location id="id90" x="-442" y="-51">
			<committed/>
		</location>
		<location id="id91" x="-442" y="102">
		</location>
		<init ref="id89"/>
		<transition>
			<source ref="id91"/>
			<target ref="id89"/>
			<label kind="guard" x="-357" y="8">!GlobalMemoryIsScrambled</label>
			<label kind="synchronisation" x="-357" y="25">FlashReadReturn!</label>
			<label kind="assignment" x="-357" y="42">startIndex = 0,
endIndex = 0</label>
			<nail x="-425" y="85"/>
			<nail x="-136" y="85"/>
			<nail x="-136" y="-34"/>
			<nail x="-136" y="-34"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id89"/>
			<label kind="assignment" x="-93" y="-8">startIndex = 0,
endIndex = 0</label>
		</transition>
		<transition>
			<source ref="id88"/>
			<target ref="id87"/>
			<label kind="synchronisation" x="51" y="-68">TryWriteMemory[startIndex][endIndex]!</label>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id88"/>
			<label kind="select" x="-42" y="-187">s : int[0, MemoryMaxIndex - 1],
e : int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-42" y="-153">FlashWrite[s][e]?</label>
			<label kind="assignment" x="-42" y="-136">startIndex = s,
endIndex = e</label>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id89"/>
			<label kind="guard" x="-357" y="110">GlobalMemoryIsScrambled</label>
			<label kind="synchronisation" x="-357" y="127">FlashReadReturn!</label>
			<label kind="assignment" x="-357" y="144">unscramble(),
startIndex = 0,
endIndex = 0</label>
			<label kind="comments" x="-102" y="119">Den globale variable, der returneres,
bør fanges af FlashController, og tjekkes
for scramble, evt. unscrambles, og derefter
sende det "en tak længere op" så det kan 
gives til intended user.</label>
			<nail x="-119" y="102"/>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id91"/>
			<label kind="synchronisation" x="-688" y="0">TryReadMemory[startIndex][endIndex]!</label>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id90"/>
			<label kind="select" x="-399" y="-153">s : int[0, MemoryMaxIndex - 1],
e : int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-399" y="-119">FlashRead[s][e]?</label>
			<label kind="assignment" x="-399" y="-102">startIndex = s,
endIndex = e</label>
		</transition>
	</template>
	<template>
		<name>ExceptionHandler</name>
		<location id="id92" x="-102" y="-102">
			<name x="-85" y="-136">Exception_Raised</name>
			<committed/>
		</location>
		<location id="id93" x="-238" y="-102">
		</location>
		<init ref="id93"/>
		<transition>
			<source ref="id93"/>
			<target ref="id92"/>
			<label kind="synchronisation" x="-221" y="-136">RaiseExceptionBC?</label>
		</transition>
	</template>
	<template>
		<name>LifeCycleController</name>
		<declaration>life_cycle_state_t State = {54, 9, -2, 11, 27};

</declaration>
		<location id="id94" x="0" y="-68">
			<committed/>
		</location>
		<location id="id95" x="-136" y="-68">
		</location>
		<init ref="id95"/>
		<transition>
			<source ref="id94"/>
			<target ref="id95"/>
			<label kind="synchronisation" x="-136" y="-34">ReturnLifeCycleState!</label>
			<label kind="assignment" x="-136" y="-17">GlobalLifeCycleState = State</label>
			<nail x="-68" y="-34"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id94"/>
			<label kind="synchronisation" x="-127" y="-127">RequestLifeCycleState?</label>
			<nail x="-68" y="-102"/>
		</transition>
	</template>
	<template>
		<name>HMAC</name>
		<declaration>
int secretKey = 0; // burde komme fra KM.
int Opad;
int Ipad;
int loopIndex = 0;
int message;

int[0,4] Progress = 0;


void calculateOuterPadding(){
}

void calculateInnerPadding(){
}

void calculateMessagePadding(){

}

void breakIntoChunks(){
}

void hash(){
}

void wipeSecretKey(int num){
    if (num == 1)
        secretKey = 0;
}
bool my_xor(bool a, bool b){
    return a != b;
}
/*
void calculateOPad(){
    //o_key_pad = secretKey xor [0x5c * blockSize / 8]    Outer padded key
    int i;
    for(i = 0; i &lt; blockSize / 8; i++)
    {
        oPad[i] = my_xor(secretKey[i],0);
        oPad[i+1] = my_xor(secretKey[i+1],1);
        oPad[i+2] = my_xor(secretKey[i+2],0);
        oPad[i+3] = my_xor(secretKey[i+3],1);
        oPad[i+4] = my_xor(secretKey[i+4],1);
        oPad[i+5] = my_xor(secretKey[i+5],1);
        oPad[i+6] = my_xor(secretKey[i+6],0);
        oPad[i+7] = my_xor(secretKey[i+7],0);
    }
}

void calculateIPad(){
    //i_key_pad = secretKey xor [0x36 * blockSize / 8]   // Inner padded key
    int i;
    for(i = 0; i &lt; blockSize / 8; i++)
    {
        iPad[i] = my_xor(secretKey[i],0);
        iPad[i+1] = my_xor(secretKey[i+1],0);
        iPad[i+2] = my_xor(secretKey[i+2],1);
        iPad[i+3] = my_xor(secretKey[i+3],1);
        iPad[i+4] = my_xor(secretKey[i+4],0);
        iPad[i+5] = my_xor(secretKey[i+5],1);
        iPad[i+6] = my_xor(secretKey[i+6],1);
        iPad[i+7] = my_xor(secretKey[i+7],0);
    }
}
/*
void hash(int size) // Takes and returns a bit array
{
    int i;
    for (i = 0; i &lt; outputSize; i++)
    {
        result[i] = intermediateResult[i];
    }
}
*/
/*
void HMAC() // Assuming the key is always exactly 512 bits long.
{
    int i;
    calculateOPad();
    calculateIPad();
    
    //hash(o_key_pad ∥ hash(i_key_pad ∥ message))

    
    for(i = 0; i &lt; blockSize; i++)
    {
        intermediateResult[i] = iPad[i];
        intermediateResult[i + blockSize] = message[i];
    }
    hash(blockSize * 2);
    
    for(i = 0; i &lt; blockSize; i++)
    {
        intermediateResult[i] = oPad[i];
        if (i &lt; outputSize)
            intermediateResult[i + blockSize] = result[i];
    }
    
    hash(outputSize + blockSize);
}*/</declaration>
		<location id="id96" x="-680" y="-170">
		</location>
		<location id="id97" x="-952" y="-170">
		</location>
		<location id="id98" x="-952" y="-408">
		</location>
		<location id="id99" x="-680" y="-408">
		</location>
		<init ref="id97"/>
		<transition>
			<source ref="id99"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-654" y="-314">ReturnSecretKey?</label>
			<label kind="assignment" x="-680" y="-289">secretKey = GlobalSecretKey,
GlobalSecretKey = 0,
Progress = 1</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id99"/>
			<label kind="synchronisation" x="-892" y="-433">RequestSecretKey!</label>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id96"/>
			<label kind="guard" x="-526" y="-204">loopIndex &lt; 2</label>
			<label kind="assignment" x="-527" y="-187">calculateMessagePadding(),
breakIntoChunks(),
hash(),
loopIndex += 1,
Progress += 1</label>
			<nail x="-612" y="-238"/>
			<nail x="-544" y="-170"/>
			<nail x="-612" y="-102"/>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id97"/>
			<label kind="select" x="-867" y="-153">i : int[0,1]</label>
			<label kind="guard" x="-867" y="-136">loopIndex &gt;= 2</label>
			<label kind="synchronisation" x="-867" y="-119">HMACReturn!</label>
			<label kind="assignment" x="-867" y="-102">loopIndex = 0,
wipeSecretKey(i),
GlobalImageCode = message,
Progress = 4</label>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id98"/>
			<label kind="synchronisation" x="-1139" y="-323">HMACCalled?</label>
			<label kind="assignment" x="-1139" y="-306">calculateInnerPadding(),
calculateOuterPadding(),
message = GlobalImageCode,
Progress = 0</label>
		</transition>
	</template>
	<template>
		<name>KeyManager</name>
		<declaration>// Contains keys
// derives keys from other keys and seeds
// makes keys visible to certain other SW components.

life_cycle_state_t LifeCycleState;

int[0,3] InternalState;
// 0 -&gt; reset
// 1 -&gt; Initialized
// 2 -&gt; CreatorRootKey
// 3 -&gt; RomExt Running

const int rootKey = 12; // Documentation says it is in OTP, so maybe it does not belong here.
int CreatorRootKey = -1;
void deriveSecretKey(){
    
}

</declaration>
		<location id="id100" x="-357" y="-272">
		</location>
		<location id="id101" x="-637" y="-306">
		</location>
		<location id="id102" x="-467" y="-144">
			<name x="-450" y="-170">OwnerIntermediateKey</name>
			<label kind="comments" x="-450" y="-144">Derive more keys, but this is out of scope</label>
		</location>
		<location id="id103" x="-467" y="-272">
			<name x="-484" y="-238">CreatorRootKeyDerived</name>
		</location>
		<location id="id104" x="-467" y="-596">
			<name x="-543" y="-604">Initialized</name>
			<committed/>
		</location>
		<location id="id105" x="-467" y="-629">
			<name x="-526" y="-637">Reset</name>
		</location>
		<location id="id106" x="-467" y="-536">
			<committed/>
		</location>
		<location id="id107" x="-467" y="-451">
			<committed/>
		</location>
		<location id="id108" x="-467" y="-391">
			<committed/>
		</location>
		<location id="id109" x="-731" y="-272">
		</location>
		<location id="id110" x="-671" y="-238">
		</location>
		<location id="id111" x="-612" y="-178">
		</location>
		<init ref="id105"/>
		<transition>
			<source ref="id110"/>
			<target ref="id111"/>
			<label kind="assignment" x="-739" y="-212">WriteSRAM[][]</label>
		</transition>
		<transition>
			<source ref="id100"/>
			<target ref="id103"/>
			<label kind="synchronisation" x="-450" y="-314">ReturnScrambleKey!</label>
			<label kind="assignment" x="-450" y="-305">GlobalSecretKey = 27</label>
			<nail x="-408" y="-289"/>
		</transition>
		<transition>
			<source ref="id103"/>
			<target ref="id100"/>
			<label kind="synchronisation" x="-450" y="-255">RequestScrambleKey?</label>
			<nail x="-408" y="-255"/>
		</transition>
		<transition>
			<source ref="id109"/>
			<target ref="id110"/>
			<label kind="synchronisation" x="-824" y="-246">KMACReturn?</label>
			<nail x="-731" y="-238"/>
		</transition>
		<transition>
			<source ref="id101"/>
			<target ref="id109"/>
			<label kind="synchronisation" x="-909" y="-357">KMACCalled!</label>
			<label kind="assignment" x="-909" y="-340">GlobalSecretKey = CreatorRootKey</label>
			<nail x="-731" y="-306"/>
		</transition>
		<transition>
			<source ref="id108"/>
			<target ref="id103"/>
			<label kind="synchronisation" x="-459" y="-374">KMACReturn?</label>
			<label kind="assignment" x="-459" y="-357">CreatorRootKey = GlobalKMACResult,
GlobalKMACResult = 0</label>
		</transition>
		<transition>
			<source ref="id107"/>
			<target ref="id108"/>
			<label kind="synchronisation" x="-450" y="-442">KMACCalled!</label>
			<label kind="assignment" x="-450" y="-425">GlobalSecretKey = rootKey</label>
		</transition>
		<transition>
			<source ref="id106"/>
			<target ref="id107"/>
			<label kind="synchronisation" x="-450" y="-510">ReturnLifeCycleState?</label>
			<label kind="assignment" x="-450" y="-493">LifeCycleState = GlobalLifeCycleState</label>
		</transition>
		<transition>
			<source ref="id111"/>
			<target ref="id103"/>
			<label kind="synchronisation" x="-595" y="-187">ReturnSecretKey!</label>
			<nail x="-510" y="-238"/>
		</transition>
		<transition>
			<source ref="id103"/>
			<target ref="id101"/>
			<label kind="synchronisation" x="-620" y="-332">RequestSecretKey?</label>
			<nail x="-510" y="-306"/>
		</transition>
		<transition>
			<source ref="id103"/>
			<target ref="id102"/>
			<label kind="synchronisation" x="-450" y="-204">AdvanceKMState?</label>
		</transition>
		<transition>
			<source ref="id104"/>
			<target ref="id106"/>
			<label kind="synchronisation" x="-450" y="-578">RequestLifeCycleState!</label>
		</transition>
		<transition>
			<source ref="id105"/>
			<target ref="id104"/>
			<label kind="synchronisation" x="-467" y="-616">PowerOnBC?</label>
		</transition>
	</template>
	<template>
		<name>KMAC</name>
		<declaration>int key;
int loopIndex;
int message;
life_cycle_state_t LifeCycleState;

const int salt = 6969;

void calculateOuterPadding(){
}

void calculateInnerPadding(){
}

void calculateMessagePadding(){

}

void breakIntoChunks(){
}

void hash(){

}
void wipeSecretKey(int num){
    if (num == 1)
        key = 0;
}
int combineRegisters(){
    int result = LifeCycleState.Reg1 + LifeCycleState.Reg2 + LifeCycleState.Reg3 + LifeCycleState.Reg4 + LifeCycleState.Reg5;
    if (result == 0) // If the life cycle state is not set:
        result = (salt * key) % 34;
    else
        result = (result + key) % 34;
    return result;
}
void clearLifeCycleState(){
    LifeCycleState.Reg1 = 0;
    LifeCycleState.Reg2 = 0;
    LifeCycleState.Reg3 = 0;
    LifeCycleState.Reg4 = 0;
    LifeCycleState.Reg5 = 0;
}</declaration>
		<location id="id112" x="459" y="255">
			<committed/>
		</location>
		<location id="id113" x="323" y="255">
		</location>
		<init ref="id113"/>
		<transition>
			<source ref="id112"/>
			<target ref="id112"/>
			<label kind="guard" x="613" y="221">loopIndex &lt; 2</label>
			<label kind="assignment" x="612" y="238">breakIntoChunks(),
hash(),
loopIndex += 1</label>
			<label kind="comments" x="612" y="204">Number of loops could be set to 24 to simulate real-life</label>
			<nail x="527" y="187"/>
			<nail x="595" y="255"/>
			<nail x="527" y="323"/>
		</transition>
		<transition>
			<source ref="id112"/>
			<target ref="id113"/>
			<label kind="select" x="297" y="340">i : int[0,1]</label>
			<label kind="guard" x="297" y="357">loopIndex &gt;= 2</label>
			<label kind="synchronisation" x="297" y="374">KMACReturn!</label>
			<label kind="assignment" x="297" y="391">loopIndex = 0,
wipeSecretKey(i),
GlobalKMACResult = message,
clearLifeCycleState()</label>
			<nail x="391" y="323"/>
		</transition>
		<transition>
			<source ref="id113"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="297" y="76">KMACCalled?</label>
			<label kind="assignment" x="297" y="93">key = GlobalSecretKey,
LifeCycleState = GlobalLifeCycleState,
message = combineRegisters(),
GlobalSecretKey = 0</label>
			<nail x="391" y="187"/>
		</transition>
	</template>
	<system>system SystemReset, ROMStage, Flash, rom_ext_manifests_to_try, CheckPubKeyValid, ValidityCheckObserver, 
       RSAModule, RomExt, PmpModule, Zeno, final_jump_to_rom_ext, ReadBootPolicy, CheckRomExtManifest, 
       ExceptionHandler, ReadPublicKey, LifeCycleController, HMAC, KeyManager, KMAC, FlashController,
       SRAMController, SRAM, MemoryHandling;
    </system>
	<queries>
		<query>
			<formula>A[] ROMStage.ReadyToRunROMExt imply (PmpRegions[0].execute &amp;&amp; PmpRegions[0].startAddress &lt;= ROMStage.currentManifest.entryPoint &amp;&amp; PmpRegions[0].endAddress &gt;= ROMStage.currentManifest.entryPoint)</formula>
			<comment>Whenever the rom ext is running, it must be true, that the PMP regions allow for executing that entrypoint.</comment>
		</query>
		<query>
			<formula>E[] not( ROMStage.Boot_Failed || ROMStage.Rom_Ext_terminated)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] not( ROMStage.Boot_Failed || ROMStage.Rom_Ext_terminated)</formula>
			<comment>The ROM Stage will never fail. This is due to the hardcoded values in the manifest / memory. If we eventually implement non-determinism, we expect that this property might not hold.</comment>
		</query>
		<query>
			<formula>ROMStage.currentManifest.identifier != 1 --&gt; (ROMStage.StartOfLoop || ROMStage.Boot_Failed)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>(ROMStage.currentManifest.signature != 1 || ROMStage.currentManifest.image_code != 1) --&gt; (ROMStage.StartOfLoop || ROMStage.Boot_Failed)</formula>
			<comment>If the signature cannot be decrypted and be equal to the image code, the state will eventually be back to startOfLoop</comment>
		</query>
		<query>
			<formula>A[] ROMStage.ReadyToRunROMExt imply (ROMStage.currentManifest.signature == 1 &amp;&amp; ROMStage.currentManifest.image_code == 1)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ROMStage.ReadyToRunROMExt imply ROMStage.currentManifest.identifier == 1</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; final_jump_to_rom_ext.ROM_ext_running</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; final_jump_to_rom_ext.ROM_ext_running</formula>
			<comment>We will always reach a state where the rom ext is running.</comment>
		</query>
		<query>
			<formula>A[] ExceptionHandler.Exception_Raised imply SRAMController.scrambled</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] final_jump_to_rom_ext.ROM_ext_running imply (ROMStage.currentManifest.publicKey.exponent == 1 &amp;&amp; ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp; ROMStage.currentManifest.signature == 1 &amp;&amp; ROMStage.currentManifest.identifier == 1)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ROMStage.SignatureCheck imply (ROMStage.currentManifest.publicKey.exponent == 1 &amp;&amp; ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp; ROMStage.currentManifest.identifier == 1)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] final_jump_to_rom_ext.ROM_ext_running imply GlobalMemoryIsScrambled == false</formula>
			<comment>More a debug check than a security check. Could we ever have that we are reading a scrambled value? No the query states that the most recently read value will always get unscrambled. </comment>
		</query>
		<query>
			<formula>A[] ROMStage.CheckedSignature imply (ROMStage.currentManifest.identifier == 1 &amp;&amp; ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp; ROMStage.currentManifest.publicKey.exponent == 1 &amp;&amp; ROMStage.currentManifest.signature == 1)</formula>
			<comment>Belræfter at man ved ROMStage.CheckedSignature altid har et i alle felterne i manifestet</comment>
		</query>
		<query>
			<formula>A[] ROMStage.CheckingSignature imply (ROMStage.currentManifest.identifier == 1 &amp;&amp; ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp; ROMStage.currentManifest.publicKey.exponent == 1)</formula>
			<comment>Bekræfter at man ved ROMStage.CheckingSignature altid har 1 i de felter der er blevet checket</comment>
		</query>
		<query>
			<formula>A[] ROMStage.IdentifierChecked imply ROMStage.currentManifest.identifier == 1</formula>
			<comment>Bekræfter at man altid har 1 i identifer efter man har lavet checket.</comment>
		</query>
		<query>
			<formula>A[] FlashController.Idle imply !GlobalMemoryIsScrambled</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
