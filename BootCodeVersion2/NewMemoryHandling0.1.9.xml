<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Når man tænder, er hele flash read-only og locked.
// Når man har verificeret noget, "åbner" man en region gennem PMP, så det kan eksekveres.
/*
TEST PURPOSE KEY PAIR:
Private Key: (143, 103)
Public Key: (143, 7)
Primes: p = 11, q = 13
Totient = 120
*/
const int MemoryMaxIndex = 100;
const int NumberOfFlashBanks = 1; 
const int NumberOfKeysInWhitelist = 1; //Calculated ids will always be either 1 or 0 so more ids in whitelist does not add anything atm.
const int NumberOfFieldsInSRAM = 6;


// OTP value indices
const int RootKeyIndex = 0;
const int SramSeedIndex = 1;
const int FlashSeedIndex = 2;
const int LifeCycleIndex = 3;

typedef struct{
    int identifier;
    int rom_ext_slot[NumberOfFlashBanks]; // Address of Flash Bank
    
    //what to do if all ROM Ext are invalid
    //void (*fail) ();    
    int fail_function_address;

    //what to do if the ROM Ext unexpectedly returns
    //void (*fail_rom_ext_terminated) (rom_ext_manifest_t);   
    int rom_ext_failure_function_address;
} boot_policy_t;

typedef struct {
    int[0,2] exponent;
    int[0,2] modulus;
} pub_key_t; // If both fields of this struct are 1 then it evaluates to a correct key

typedef struct {
    int exponent;
    int modulus;
} sig_key_t;

typedef struct {
    int[0,2] identifier; // 0 -&gt; missing, 1 -&gt; contains magic value, 2 -&gt; does not contain magic value
    int entryPoint; //address in memory
    pub_key_t publicKey; // The public key used to verify the signature of the manifest
    int[0,2] signature; // 0 -&gt; missing, 1 -&gt; correct signature, 2 -&gt; bad signature
    //pub_key_t pub_signature_key;
    int[0,2] image_code; // 0 -&gt; missing, 1 -&gt; correct image code, 2 -&gt; hashed image code
} rom_ext_manifest_t;

typedef struct {
    int size;
    rom_ext_manifest_t rom_exts_mfs[NumberOfFlashBanks]; 
} rom_exts_manifests_t;

typedef struct{
    int startAddress;
    int endAddress;
    bool read;
    bool write;
    bool execute;
    bool locked;
} PmpRegion_t;

typedef struct{
    int Reg1;
    int Reg2;
    int Reg3;
    int Reg4;    
    int Reg5;
} life_cycle_state_t;

PmpRegion_t PmpRegions[16];
const rom_ext_manifest_t validManifest = {1,38,{1,1},1,1};

//Empty structs for comparison

boot_policy_t GlobalEmptyBootPolicy;
/*GlobalEmptyBootPolicy.identifer = 0;
GlobalEmptyBootPolicy.rom_ext_slot[0] = 0;
GlboalEmptyBootPolicy.fail_function_address = 0;
GlobalEmptyBootPoicy.rom_ext_failure_function_address = 0;
*/
rom_ext_manifest_t GlobalEmptyManifest = {0,0,{0,0},0,0};
/*GlobalEmptyManifest.identifier = 0;
GlobalEmptyManifest.entryPoint = 0;
GlobalEmptyManifest.signature = 0;
GlobalEmptyManifest.image_code = 0;*/

pub_key_t GlobalEmptyPublicKey = {0,0};
/*GlobalEmptyPublicKey.exponent = 0;
GlobalEmptyPublicKey.modulus = 0;*/
rom_exts_manifests_t GlobalEmptyManifests;
//int GlobalMemory[MemoryMaxIndex];
boot_policy_t GlobalBootPolicy;
rom_exts_manifests_t GlobalRomExtsManifests;
pub_key_t GlobalPublicKey;
pub_key_t GlobalPrivateKey;
//bool GlobalBool;
int GlobalSignature;
int GlobalImageCode;
int GlobalSecretKey;
int GlobalKMACResult;
int[0,4] GlobalDigest = 0;
rom_ext_manifest_t GlobalManifest;
life_cycle_state_t GlobalLifeCycleState;
bool GlobalMemoryIsScrambled; // Indicates whether the most recently read memory was scrambled or not.
int[-1, 1] GlobalPublicKeyIdWhitelist[NumberOfKeysInWhitelist] = {-1};
int GlobalOTPStorage;
int GlobalEntropy;

broadcast chan PowerOnBC;
chan StartRomStage;

broadcast chan CheckRomExtManifestCallBC;
chan CheckRomExtManifestValid;
broadcast chan CheckRomExtManifestNotValidBC;

chan TryReadMemory[MemoryMaxIndex][MemoryMaxIndex];
chan TryWriteMemory[MemoryMaxIndex][MemoryMaxIndex];
chan TryExecuteMemory[MemoryMaxIndex][MemoryMaxIndex];

chan GetEntropy;
chan OTPEntropy, PassEntropy, KeyManagerEntropy;

chan ReadBootPolicyCall,
     ReadBootPolicyReturn;

chan REMTTCall, // Rom Ext Manifests To Try
     REMTTReturn;

chan PmpWriteMemory[MemoryMaxIndex][MemoryMaxIndex],
     PmpReadMemory[MemoryMaxIndex][MemoryMaxIndex];

broadcast chan FinalJumpCallBC;
chan FinalJumpReturn;

chan Rom_Ext_Fail;
broadcast chan RaiseExceptionBC;

broadcast chan ReadPublicKeyCallBC; 
chan ReadPublicKeyReturn;

chan HMACReturn,
     HMACCalled;

chan KMACReturn,
     KMACCalled;

chan RequestLifeCycleState,
     ReturnLifeCycleState;

chan FlashReadReturn;

chan SignalSRAMWrite, SignalSRAMWriteReturn;

chan SignalSRAMRead[NumberOfFieldsInSRAM],SignalSRAMReadReturn;

chan WriteMemory, WriteMemoryReturn;

broadcast chan GetRootKeyBC;

chan HashCalled, HashReturn;

broadcast chan CheckPublicKeyValidCallBC,
               PubKeyNotValidBC,
               PubKeyValidBC;

broadcast chan CheckSignatureBC,
               RSAValidBC,
               RSANotValidBC;

broadcast chan SignatureNotValidBC;
chan SignatureValid;

broadcast chan VerifyRomExtSignatureCallBC;

broadcast chan RomExtValidBC[MemoryMaxIndex],
               RomExtNotValidBC;

chan RomExtStart[MemoryMaxIndex];
chan ReturnSecretKey,
     RequestSecretKey;

chan AdvanceKMState;

chan FlashRead[MemoryMaxIndex][MemoryMaxIndex],
     FlashWrite[MemoryMaxIndex][MemoryMaxIndex];

//SRAM Controller channels
chan CheckSRAM[NumberOfFieldsInSRAM],
     CheckSRAMReturn,
     NotInSRAM;

chan ReadSRAM[NumberOfFieldsInSRAM],
     ReadSRAMReturn,
     ReadSRAMScrambled[NumberOfFieldsInSRAM];
chan WriteSRAM,
     WriteSRAMReturn;
    

chan RequestScrambleKey,
     ReturnScrambleKey;

chan ReturnEDN, RequestEDN, RequestEntropy;

//Channels for overall memory handling (reading from SRAM or Flash)
chan ReadMemory[MemoryMaxIndex][MemoryMaxIndex],
     ReadMemoryReturn;
chan WritePrivateKeyToSRAM, WritePrivateKey;


chan WriteManifest, WriteBootPolicy, WriteImageCode, WritePublicKey, 
WriteDigest, WriteManifestToSRAM, WriteBootPolicyToSRAM, 
WriteImageCodeToSRAM, WritePublicKeyToSRAM, WriteDigestToSRAM,
WriteSignature, WriteSignatureToSRAM;

chan ReadManifestFromSRAM, ReadBootPolicyFromSRAM, 
ReadImageCodeFromSRAM, ReadPublicKeyFromSRAM, ReadDigestFromSRAM;


// OTP and OTP Controller related channels
chan OTPRead[4];

chan RequestFlashScramblingKey, ReturnFlashScramblingKey,
     RequestSRAMScramblingKey, ReturnSRAMScramblingKey,
     RequestLifeCyclePartition, ReturnLifeCyclePartition;

chan WriteKeyIdWhitelistToSRAM;
chan WritePublicKeyIdWhitelist;
chan WritePublicKeyIdWhitelistToSRAM;
void clearGlobalMemory(){
    int i;
    //for(i = 0; i &lt; MemoryMaxIndex; i++)
       // GlobalMemory[i] = 0;
}

void clearGlobalBootPolicy(){
    int i;
    GlobalBootPolicy.identifier = 0;
    for(i = 0; i &lt; NumberOfFlashBanks; i++)
        GlobalBootPolicy.rom_ext_slot[i] = 0; 
    GlobalBootPolicy.fail_function_address = 0;  
    GlobalBootPolicy.rom_ext_failure_function_address = 0;
}

void clearGlobalRomExtsManifests(){
    int i, j;
    GlobalRomExtsManifests.size = 0;
    for(i = 0; i &lt; NumberOfFlashBanks; i++){
        GlobalRomExtsManifests.rom_exts_mfs[i].identifier = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].entryPoint = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].signature = 0;
        GlobalRomExtsManifests.rom_exts_mfs[i].image_code = 0;
    }
}

void clearGlobalPublicKey(){
    GlobalPublicKey.exponent = 0;
    GlobalPublicKey.modulus = 0;
}

void clearGlobalPubKeyWhitelist(){
    int i;
    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++) 
        GlobalPublicKeyIdWhitelist[i] = 0;
}

int powerMod(int root, int exponent, int modulus){ // root ^ exponent % modulus
    int result = 1;
    int i;    

    if (root == 0 || modulus == 0)
        return 0;
    if (exponent == 0)
        return 1;

    for(i = 0; i &lt; exponent; i++){
        result *= root;
        result %= modulus;
    }

    return result;
}

void clearGlobalManifest(){
    int i;
    GlobalManifest.identifier = 0;
    GlobalManifest.entryPoint = 0;
    GlobalManifest.publicKey.exponent = 0;
    GlobalManifest.publicKey.modulus = 0; 
    GlobalManifest.image_code = 0;
    GlobalManifest.signature = 0;
}

void clearGlobalLifeCycleState(){
    GlobalLifeCycleState.Reg1 = 0;
    GlobalLifeCycleState.Reg2 = 0;
    GlobalLifeCycleState.Reg3 = 0;    
    GlobalLifeCycleState.Reg4 = 0;
    GlobalLifeCycleState.Reg5 = 0;
}

bool EqualManifestContents(rom_ext_manifest_t manifest1, rom_ext_manifest_t manifest2){
    return manifest1.identifier == manifest2.identifier &amp;&amp;
           manifest1.publicKey.exponent == manifest2.publicKey.exponent &amp;&amp;
           manifest1.publicKey.modulus == manifest2.publicKey.modulus &amp;&amp;
           manifest1.image_code == manifest2.image_code &amp;&amp;
           manifest1.signature == manifest2.signature;
}
void ClearGlobalKeyIdList(){
    int i;
    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++)
    {
        GlobalPublicKeyIdWhitelist[i] = -1;
    }
}</declaration>
	<template>
		<name>HASH</name>
		<declaration>int message;

int SHA(int msg){
    return msg;
}</declaration>
		<location id="id0" x="-306" y="-34">
		</location>
		<location id="id1" x="-238" y="-136">
		</location>
		<location id="id2" x="-306" y="-238">
		</location>
		<location id="id3" x="-442" y="-238">
		</location>
		<location id="id4" x="-510" y="-136">
		</location>
		<location id="id5" x="-442" y="-34">
		</location>
		<init ref="id4"/>
		<transition>
			<source ref="id0"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-433" y="-17">WriteMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-256" y="-85">WriteMemory!</label>
			<label kind="assignment" x="-255" y="-68">GlobalDigest = SHA(message)</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-561" y="-76">HashReturn!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-255" y="-221">CheckSRAMReturn?</label>
			<label kind="assignment" x="-255" y="-204">message = GlobalImageCode,
GlobalImageCode = 0</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-433" y="-272">CheckSRAM[2]!</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-569" y="-204">HashCalled?</label>
		</transition>
	</template>
	<template>
		<name>SystemReset</name>
		<location id="id6" x="187" y="-51">
		</location>
		<location id="id7" x="51" y="-51">
		</location>
		<location id="id8" x="-51" y="-51">
		</location>
		<init ref="id8"/>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="59" y="-76">StartRomStage!</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-42" y="-76">PowerOnBC!</label>
		</transition>
	</template>
	<template>
		<name>VerifyRomExtSignature</name>
		<declaration>rom_ext_manifest_t manifest;
//pub_key_t publicKey;
//int digest;

void hash(int a){
    a = a + 2;
}</declaration>
		<location id="id9" x="-1275" y="-255">
		</location>
		<location id="id10" x="-1207" y="-255">
		</location>
		<location id="id11" x="-926" y="-187">
			<name x="-936" y="-221">WritingSignature</name>
		</location>
		<location id="id12" x="-1241" y="-187">
			<name x="-1368" y="-187">WaitingForOTBN</name>
		</location>
		<location id="id13" x="-1241" y="-323">
			<name x="-1258" y="-357">Idle</name>
		</location>
		<location id="id14" x="-586" y="-323">
		</location>
		<location id="id15" x="-586" y="-187">
			<name x="-577" y="-221">WaitingForHash</name>
		</location>
		<location id="id16" x="-688" y="-187">
		</location>
		<location id="id17" x="-1011" y="-323">
		</location>
		<location id="id18" x="-739" y="-323">
			<name x="-849" y="-357">WritingImageCode</name>
		</location>
		<location id="id19" x="-1088" y="-187">
		</location>
		<init ref="id13"/>
		<transition>
			<source ref="id9"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-1411" y="-297">SignatureNotValidBC!</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-1215" y="-289">SignatureValid!</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-1377" y="-238">RSANotValidBC?</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-1215" y="-238">RSAValidBC?</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-1071" y="-178">WriteMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-909" y="-178">WriteMemory!</label>
			<label kind="assignment" x="-909" y="-161">GlobalSignature = manifest.signature</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1224" y="-178">CheckSignatureBC!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-731" y="-348">WriteMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-994" y="-314">WriteMemory!</label>
			<label kind="assignment" x="-994" y="-297">GlobalImageCode = manifest.image_code,
clearGlobalManifest()</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-680" y="-178">HashReturn?</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-578" y="-263">HashCalled!</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-1215" y="-382">VerifyRomExtSignatureCallBC?</label>
			<label kind="assignment" x="-1215" y="-365">manifest = GlobalManifest</label>
		</transition>
	</template>
	<template>
		<name>OTPController</name>
		<declaration>int OTPvalue;
int entropy;

void derive(){
    OTPvalue += 1;
}    </declaration>
		<location id="id20" x="433" y="119">
		</location>
		<location id="id21" x="-255" y="0">
		</location>
		<location id="id22" x="0" y="0">
		</location>
		<location id="id23" x="272" y="0">
		</location>
		<location id="id24" x="0" y="-170">
		</location>
		<location id="id25" x="-255" y="119">
		</location>
		<location id="id26" x="272" y="119">
		</location>
		<location id="id27" x="0" y="-85">
		</location>
		<location id="id28" x="255" y="144">
		</location>
		<location id="id29" x="-221" y="-170">
		</location>
		<location id="id30" x="8" y="221">
		</location>
		<location id="id31" x="-204" y="221">
		</location>
		<init ref="id29"/>
		<transition>
			<source ref="id31"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-170" y="161">ReturnLifeCyclePartition!</label>
			<nail x="-204" y="187"/>
			<nail x="0" y="187"/>
			<nail x="0" y="34"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-178" y="195">OTPRead[LifeCycleIndex]!</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="17" y="170">RequestLifeCyclePartition?</label>
			<nail x="8" y="25"/>
			<nail x="8" y="42"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="-187" y="-195">PowerOnBC?</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="280" y="153">ReturnEDN?</label>
			<label kind="assignment" x="280" y="170">entropy = GlobalEntropy,
GlobalEntropy = 0</label>
			<nail x="433" y="144"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="290" y="102">RequestEDN!</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="0" y="-59">GetRootKeyBC!</label>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="51" y="17">ReturnSRAMScramblingKey!</label>
			<label kind="assignment" x="51" y="34">OTPvalue = GlobalOTPStorage,
derive(),
GlobalOTPStorage = OTPvalue</label>
			<nail x="255" y="17"/>
			<nail x="17" y="17"/>
			<nail x="17" y="17"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-230" y="17">ReturnFlashScramblingKey!</label>
			<label kind="assignment" x="-230" y="34">OTPvalue = GlobalOTPStorage,
derive(),
GlobalOTPStorage = OTPvalue</label>
			<nail x="-238" y="102"/>
			<nail x="-238" y="17"/>
			<nail x="-17" y="17"/>
			<nail x="-17" y="17"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-433" y="42">OTPRead[FlashSeedIndex]!</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-204" y="-34">RequestFlashScramblingKey?</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="0" y="-144">OTPRead[RootKeyIndex]!</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="34" y="-34">RequestSRAMScramblingKey?</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="272" y="34">OTPRead[SramSeedIndex]!</label>
		</transition>
	</template>
	<template>
		<name>EntropySource</name>
		<location id="id32" x="-51" y="-51">
		</location>
		<init ref="id32"/>
		<transition>
			<source ref="id32"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="-25" y="-34">GetEntropy?</label>
			<label kind="assignment" x="-25" y="-17">GlobalEntropy = 1</label>
			<nail x="-68" y="0"/>
			<nail x="-34" y="0"/>
		</transition>
	</template>
	<template>
		<name>EDN</name>
		<declaration>int entropy;</declaration>
		<location id="id33" x="-1258" y="-986">
		</location>
		<location id="id34" x="-1258" y="-1079">
		</location>
		<location id="id35" x="-1139" y="-1079">
		</location>
		<location id="id36" x="-1139" y="-986">
		</location>
		<init ref="id35"/>
		<transition>
			<source ref="id36"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-1130" y="-1045">ReturnEDN!</label>
			<label kind="assignment" x="-1130" y="-1028">GlobalEntropy = entropy</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-1249" y="-969">PassEntropy?</label>
			<label kind="assignment" x="-1249" y="-952">entropy = GlobalEntropy,
GlobalEntropy = 0</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-1377" y="-1045">RequestEntropy!</label>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-1241" y="-1113">RequestEDN?</label>
			<nail x="-1199" y="-1079"/>
		</transition>
	</template>
	<template>
		<name>CSRNG</name>
		<declaration>void RNG(){
    GlobalEntropy += 1;
}</declaration>
		<location id="id37" x="0" y="0">
		</location>
		<location id="id38" x="136" y="0">
		</location>
		<location id="id39" x="68" y="-102">
		</location>
		<init ref="id39"/>
		<transition>
			<source ref="id39"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-85" y="-102">RequestEntropy?</label>
			<nail x="0" y="-68"/>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="144" y="-102">PassEntropy!</label>
			<label kind="assignment" x="187" y="-85">RNG()</label>
			<nail x="136" y="-68"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="34" y="42">GetEntropy!</label>
			<nail x="68" y="34"/>
		</transition>
	</template>
	<template>
		<name>OTP</name>
		<declaration>const int[12,12] rootKey = 12;
const int sramScramblingKeySeed = 0;
const int flashScramblingKeySeed = 1;
int lifeCycleState = 1;

void readOTP(int index){
    if (index == RootKeyIndex)
    {
        GlobalOTPStorage = rootKey;
    }
    if (index == SramSeedIndex)
    {
        GlobalOTPStorage = sramScramblingKeySeed;
    }
    if (index == FlashSeedIndex)
    {
        GlobalOTPStorage = flashScramblingKeySeed;
    }
    if (index == LifeCycleIndex)
    {
        GlobalOTPStorage = lifeCycleState;
    }

}</declaration>
		<location id="id40" x="-153" y="-119">
		</location>
		<init ref="id40"/>
		<transition>
			<source ref="id40"/>
			<target ref="id40"/>
			<label kind="select" x="-93" y="-153">i : int[0,3]</label>
			<label kind="synchronisation" x="-93" y="-136">OTPRead[i]?</label>
			<label kind="assignment" x="-93" y="-119">readOTP(i)</label>
			<nail x="-102" y="-153"/>
			<nail x="-102" y="-85"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Flash</name>
		<declaration>//int memory[MemoryMaxIndex];
// 0-19 ROM
// 20-29 Flash Info
// 30-64 Flash Bank 0
// 65-99 Flash Bank 1
/*
Flash Bank has size 35. 
The 12 first indexes are for manifest of following structure:
0: Identifier
1: Signature
2-7: Public Key
8-11: Image Code
*/
int loopIndex = 0;
rom_exts_manifests_t manifests;
int[-1, 1] pubKeyWhitelist[NumberOfKeysInWhitelist];


void loadManifest(){
    int i, j;
    rom_ext_manifest_t tempManifest;
    //Create manifest for Flash Banks
    for(i = 0; i &lt; NumberOfFlashBanks; i++){
        tempManifest.identifier = i % 2;
        tempManifest.entryPoint = 38 + (35 * i);
        
        
        
        manifests.rom_exts_mfs[i] = tempManifest;
    }
}

void initializeMemory(){
    int i;
    loadManifest();
    
    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++){
        pubKeyWhitelist[i] = i + 1;
    }
}

void readMemory(int startIndex, int endIndex){
    if(startIndex &gt;= 0 &amp;&amp; endIndex &lt;= 19){
        //Something from ROM
        if (startIndex == 13 &amp;&amp; endIndex == 13){ // public key id whitelist used for public key verification.
            GlobalPublicKeyIdWhitelist = pubKeyWhitelist; //Should be changed to an actual transference of an array from flash into the global array
            GlobalMemoryIsScrambled = true;
        }
    }
    if(startIndex &gt;= 20 &amp;&amp; endIndex &lt;= 29){
        GlobalBootPolicy.rom_ext_slot[0] = 30; // Address of flash bank 0.
        if (NumberOfFlashBanks &gt;= 2){
            GlobalBootPolicy.rom_ext_slot[1] = 65; // Address of flash bank 1.
        }
        if (NumberOfFlashBanks == 4){
            GlobalBootPolicy.rom_ext_slot[2] = 100; // Address of flash bank 2.
            GlobalBootPolicy.rom_ext_slot[3] = 135; // Address of flash bank 3.
        }
        //GlobalBootPolicy.fail_function_address = GlobalMemory[1];
        //GlobalBootPolicy.rom_ext_failure_function_address = GlobalMemory[2];
    }
    if(startIndex &gt;= 30 &amp;&amp; endIndex &lt;= 64){
        //Something from Flash Bank 0
        if(startIndex == 30 &amp;&amp; endIndex == 41){
            GlobalManifest = manifests.rom_exts_mfs[0];
            GlobalMemoryIsScrambled = true;
        }

    }
    if(startIndex &gt;= 65 &amp;&amp; endIndex &lt;= 99){
        //Something from Flash Bank 1
        if(startIndex == 65 &amp;&amp; endIndex == 76){
            GlobalManifest = manifests.rom_exts_mfs[1];
        }
    }
    else{
        if (startIndex == 100){
            GlobalManifest = manifests.rom_exts_mfs[2];
        }
        else if (startIndex == 135){
            GlobalManifest = manifests.rom_exts_mfs[3];
        }
        //You fucked up
    }
}

/*

void readMemory(v){
    int i;
    for(i = 0; i &lt;= endIndex - startIndex; i++){
        GlobalMemory[i] = memory[i + startIndex];
    }
}
*/
void writeMemory(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt;= endIndex - startIndex; i++){
        //memory[i + startIndex] = GlobalMemory[i];
    }
}




// Opdel flash bank 0-32 / 3 

// Lav en mapping til arrays af structs


</declaration>
		<location id="id41" x="-527" y="-459">
		</location>
		<location id="id42" x="-527" y="-731">
		</location>
		<location id="id43" x="-527" y="-646">
			<name x="-646" y="-671">DecideManifests</name>
			<committed/>
		</location>
		<init ref="id42"/>
		<transition>
			<source ref="id43"/>
			<target ref="id41"/>
			<label kind="guard" x="-518" y="-552">loopIndex &gt;= NumberOfFlashBanks</label>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-612" y="-714">PowerOnBC?</label>
			<label kind="assignment" x="-637" y="-697">initializeMemory()</label>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id41"/>
			<label kind="select" x="-467" y="-501">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-467" y="-467">PmpWriteMemory[s][e]?</label>
			<label kind="assignment" x="-467" y="-450">writeMemory(s,e)</label>
			<nail x="-476" y="-476"/>
			<nail x="-476" y="-442"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id41"/>
			<label kind="select" x="-782" y="-501">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-782" y="-467">PmpReadMemory[s][e]?</label>
			<label kind="assignment" x="-782" y="-450">readMemory(s,e)</label>
			<nail x="-578" y="-476"/>
			<nail x="-578" y="-442"/>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id43"/>
			<label kind="select" x="-416" y="-816">i : int[1,2],
j : int[1,2],
k : int[1,2],
l : int[1,2],
m : int[0,2]</label>
			<label kind="guard" x="-416" y="-722">loopIndex &lt; NumberOfFlashBanks</label>
			<label kind="assignment" x="-416" y="-705">manifests.rom_exts_mfs[loopIndex].image_code = i,
manifests.rom_exts_mfs[loopIndex].signature = j,
manifests.rom_exts_mfs[loopIndex].publicKey.exponent = k,
manifests.rom_exts_mfs[loopIndex].publicKey.modulus = l,
manifests.rom_exts_mfs[loopIndex].identifier = m,
manifests.rom_exts_mfs[loopIndex].entryPoint = 38 + 35 * loopIndex,
loopIndex++</label>
			<nail x="-433" y="-569"/>
			<nail x="-433" y="-739"/>
		</transition>
	</template>
	<template>
		<name>ROMStage</name>
		<declaration>rom_exts_manifests_t romExtsManifests;
rom_ext_manifest_t currentManifest;
int loopIndex = 0;
pub_key_t key;
//int entryPoint;


//void readPublicKey(){
    //Read from global??
  //  key = currentManifest.pub_signature_key;
//}

void pmpUnlockRomExt(){
    PmpRegions[0].startAddress = currentManifest.entryPoint; 
    PmpRegions[0].endAddress = currentManifest.entryPoint + 4;
    PmpRegions[0].locked = true;
    PmpRegions[0].read = true;
    PmpRegions[0].execute = true;
    PmpRegions[0].write = false;    
}

void clearManifest(){
    int i;
    currentManifest.identifier = 0;
    currentManifest.entryPoint = 0; 
    currentManifest.image_code = 0;
    currentManifest.signature = 0;
}
</declaration>
		<location id="id44" x="-85" y="17">
			<name x="-76" y="-8">CheckingKey</name>
		</location>
		<location id="id45" x="238" y="-561">
			<name x="255" y="-578">RomExtTerminated</name>
		</location>
		<location id="id46" x="238" y="-476">
			<name x="255" y="-484">RomExtRunning</name>
		</location>
		<location id="id47" x="238" y="-255">
			<name x="246" y="-272">CheckedSignature</name>
		</location>
		<location id="id48" x="238" y="-187">
			<name x="263" y="-195">CheckingSignature</name>
		</location>
		<location id="id49" x="-85" y="-357">
		</location>
		<location id="id50" x="-85" y="-561">
			<name x="-68" y="-578">BootFailed</name>
		</location>
		<location id="id51" x="-85" y="-459">
			<name x="-68" y="-484">StartOfLoop</name>
		</location>
		<location id="id52" x="-459" y="-629">
		</location>
		<location id="id53" x="-85" y="-629">
		</location>
		<location id="id54" x="238" y="-629">
		</location>
		<location id="id55" x="-459" y="-552">
		</location>
		<location id="id56" x="-459" y="-459">
		</location>
		<location id="id57" x="-85" y="-272">
			<name x="-68" y="-297">IdentifierChecked</name>
		</location>
		<location id="id58" x="76" y="-187">
			<name x="85" y="-212">SignatureCheck</name>
		</location>
		<location id="id59" x="238" y="-357">
			<name x="255" y="-374">ReadyToRunROMExt</name>
		</location>
		<location id="id60" x="-85" y="-187">
		</location>
		<location id="id61" x="-85" y="-85">
		</location>
		<init ref="id54"/>
		<transition>
			<source ref="id44"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-476" y="-25">PubKeyNotValidBC?</label>
			<label kind="assignment" x="-476" y="-8">loopIndex++</label>
			<nail x="-493" y="17"/>
			<nail x="-493" y="-425"/>
			<nail x="-408" y="-425"/>
			<nail x="-408" y="-442"/>
			<nail x="-110" y="-442"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="93" y="-8">PubKeyValidBC?</label>
			<nail x="76" y="17"/>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id44"/>
			<label kind="synchronisation" x="-272" y="-59">CheckPublicKeyValidCallBC!</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-246" y="-161">ReadPublicKeyReturn?</label>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-238" y="-246">ReadPublicKeyCallBC!</label>
			<label kind="assignment" x="-306" y="-229">GlobalManifest = currentManifest</label>
			<nail x="-85" y="-212"/>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-59" y="-425">CheckRomExtManifestNotValidBC?</label>
			<label kind="assignment" x="-59" y="-408">loopIndex++</label>
			<nail x="-68" y="-408"/>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-76" y="-323">CheckRomExtManifestValid?</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="246" y="-527">FinalJumpReturn?</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="255" y="-433">FinalJumpCallBC!</label>
			<label kind="assignment" x="255" y="-416">GlobalManifest = currentManifest</label>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="102" y="-170">VerifyRomExtSignatureCallBC!</label>
			<label kind="assignment" x="102" y="-153">GlobalManifest = currentManifest</label>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-399" y="-527">REMTTReturn?</label>
			<label kind="assignment" x="-399" y="-510">romExtsManifests = GlobalRomExtsManifests,
clearGlobalRomExtsManifests()</label>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id56"/>
			<label kind="synchronisation" x="-544" y="-510">REMTTCall!</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id59"/>
			<label kind="assignment" x="255" y="-314">pmpUnlockRomExt()</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="255" y="-229">SignatureValid?</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="51" y="-255">SignatureNotValidBC?</label>
			<label kind="assignment" x="110" y="-272">loopIndex++</label>
			<nail x="221" y="-204"/>
			<nail x="221" y="-229"/>
			<nail x="204" y="-238"/>
			<nail x="195" y="-255"/>
			<nail x="204" y="-272"/>
			<nail x="221" y="-280"/>
			<nail x="221" y="-331"/>
			<nail x="204" y="-340"/>
			<nail x="195" y="-357"/>
			<nail x="204" y="-374"/>
			<nail x="221" y="-382"/>
			<nail x="221" y="-442"/>
			<nail x="212" y="-450"/>
			<nail x="212" y="-450"/>
			<nail x="204" y="-459"/>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id49"/>
			<label kind="guard" x="-323" y="-425">loopIndex &lt; NumberOfFlashBanks</label>
			<label kind="synchronisation" x="-297" y="-408">CheckRomExtManifestCallBC!</label>
			<label kind="assignment" x="-484" y="-391">currentManifest = romExtsManifests.rom_exts_mfs[loopIndex],
GlobalManifest = currentManifest</label>
			<nail x="-102" y="-408"/>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-76" y="-518">loopIndex &gt;= NumberOfFlashBanks</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id55"/>
			<label kind="synchronisation" x="-442" y="-603">ReadBootPolicyReturn?</label>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="-357" y="-654">ReadBootPolicyCall!</label>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="42" y="-654">StartRomStage?</label>
		</transition>
	</template>
	<template>
		<name>ReadPublicKey</name>
		<declaration>rom_ext_manifest_t manifest;</declaration>
		<location id="id62" x="-1717" y="-1530">
		</location>
		<location id="id63" x="-1479" y="-1530">
		</location>
		<location id="id64" x="-1479" y="-1394">
		</location>
		<location id="id65" x="-1717" y="-1394">
		</location>
		<location id="id66" x="-1598" y="-1657">
			<committed/>
		</location>
		<init ref="id62"/>
		<transition>
			<source ref="id66"/>
			<target ref="id63"/>
			<label kind="assignment" x="-1504" y="-1615">clearGlobalManifest()</label>
		</transition>
		<transition>
			<source ref="id64"/>
			<target ref="id65"/>
			<label kind="synchronisation" x="-1666" y="-1385">WriteMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-1470" y="-1479">WriteMemory!</label>
			<label kind="assignment" x="-1470" y="-1462">GlobalPublicKey = manifest.publicKey</label>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-1861" y="-1479">ReadPublicKeyReturn!</label>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id66"/>
			<label kind="synchronisation" x="-1819" y="-1640">ReadPublicKeyCallBC?</label>
			<label kind="assignment" x="-1819" y="-1623">manifest = GlobalManifest</label>
		</transition>
	</template>
	<template>
		<name>CheckRomExtManifest</name>
		<declaration>rom_ext_manifest_t manifest;

bool checkRomExtManifest(){
    return manifest.identifier == 1;
}

void clearManifest(){
    manifest.identifier = 0;
    manifest.signature = 0;
    manifest.image_code = 0;
    manifest.entryPoint = 0;
}</declaration>
		<location id="id67" x="416" y="-51">
			<name x="433" y="-68">Called</name>
		</location>
		<location id="id68" x="17" y="-51">
			<name x="-25" y="-68">Idle</name>
		</location>
		<location id="id69" x="246" y="-51">
			<committed/>
		</location>
		<init ref="id68"/>
		<transition>
			<source ref="id69"/>
			<target ref="id67"/>
			<label kind="assignment" x="263" y="-51">clearGlobalManifest()</label>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id68"/>
			<label kind="guard" x="25" y="0">!checkRomExtManifest()</label>
			<label kind="synchronisation" x="25" y="17">CheckRomExtManifestNotValidBC!</label>
			<nail x="416" y="0"/>
			<nail x="17" y="0"/>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id68"/>
			<label kind="guard" x="34" y="-136">checkRomExtManifest()</label>
			<label kind="synchronisation" x="34" y="-119">CheckRomExtManifestValid!</label>
			<nail x="416" y="-102"/>
			<nail x="17" y="-102"/>
		</transition>
		<transition>
			<source ref="id68"/>
			<target ref="id69"/>
			<label kind="synchronisation" x="43" y="-93">CheckRomExtManifestCallBC?</label>
			<label kind="assignment" x="43" y="-76">manifest = GlobalManifest</label>
		</transition>
	</template>
	<template>
		<name>ReadBootPolicy</name>
		<declaration>void readBootPolicy(){

}</declaration>
		<location id="id70" x="-178" y="0">
			<name x="-161" y="-8">Reading</name>
		</location>
		<location id="id71" x="-374" y="-153">
			<name x="-416" y="-187">Called</name>
		</location>
		<location id="id72" x="-374" y="0">
			<name x="-416" y="-8">Idle</name>
		</location>
		<location id="id73" x="-178" y="-153">
		</location>
		<init ref="id72"/>
		<transition>
			<source ref="id73"/>
			<target ref="id70"/>
			<label kind="synchronisation" x="-170" y="-93">ReadMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id72"/>
			<label kind="synchronisation" x="-340" y="8">ReadBootPolicyReturn!</label>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id73"/>
			<label kind="synchronisation" x="-348" y="-178">ReadMemory[21][29]!</label>
		</transition>
		<transition>
			<source ref="id72"/>
			<target ref="id71"/>
			<label kind="synchronisation" x="-510" y="-85">ReadBootPolicyCall?</label>
		</transition>
	</template>
	<template>
		<name>Zeno</name>
		<location id="id74" x="-17" y="-17">
			<urgent/>
		</location>
		<init ref="id74"/>
	</template>
	<template>
		<name>RomExt</name>
		<parameter>const int[0, NumberOfFlashBanks - 1] id</parameter>
		<location id="id75" x="-153" y="-289">
		</location>
		<location id="id76" x="-153" y="-153">
		</location>
		<location id="id77" x="-357" y="-153">
		</location>
		<init ref="id77"/>
		<transition>
			<source ref="id76"/>
			<target ref="id75"/>
			<label kind="synchronisation" x="-153" y="-238">AdvanceKMState!</label>
		</transition>
		<transition>
			<source ref="id77"/>
			<target ref="id76"/>
			<label kind="synchronisation" x="-339" y="-170">RomExtStart[38 + 35 * id]?</label>
		</transition>
	</template>
	<template>
		<name>RomExtManifestsToTry</name>
		<declaration>boot_policy_t bootPolicy;
int loopIndex = 0;
</declaration>
		<location id="id78" x="595" y="-255">
			<name x="552" y="-263">Idle</name>
		</location>
		<location id="id79" x="884" y="-255">
		</location>
		<location id="id80" x="595" y="-374">
		</location>
		<location id="id81" x="884" y="-374">
		</location>
		<location id="id82" x="1054" y="-255">
		</location>
		<init ref="id78"/>
		<transition>
			<source ref="id82"/>
			<target ref="id79"/>
			<label kind="synchronisation" x="960" y="-238">ReadMemoryReturn?</label>
			<nail x="969" y="-238"/>
		</transition>
		<transition>
			<source ref="id79"/>
			<target ref="id82"/>
			<label kind="guard" x="1105" y="-340">loopIndex &lt; NumberOfFlashBanks</label>
			<label kind="synchronisation" x="1105" y="-323">ReadMemory[bootPolicy.rom_ext_slot[loopIndex]][bootPolicy.rom_ext_slot[loopIndex] + 11]!</label>
			<label kind="assignment" x="1105" y="-306">loopIndex++</label>
			<nail x="969" y="-272"/>
		</transition>
		<transition>
			<source ref="id81"/>
			<target ref="id79"/>
			<label kind="synchronisation" x="901" y="-382">CheckSRAMReturn?</label>
			<label kind="assignment" x="892" y="-365">bootPolicy = GlobalBootPolicy,
clearGlobalBootPolicy()</label>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id81"/>
			<label kind="synchronisation" x="663" y="-408">CheckSRAM[0]!</label>
		</transition>
		<transition>
			<source ref="id79"/>
			<target ref="id78"/>
			<label kind="guard" x="620" y="-246">loopIndex &gt;= NumberOfFlashBanks</label>
			<label kind="synchronisation" x="620" y="-229">REMTTReturn!</label>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id80"/>
			<label kind="synchronisation" x="510" y="-323">REMTTCall?</label>
		</transition>
	</template>
	<template>
		<name>FinalJumpToRomExt</name>
		<declaration>rom_ext_manifest_t currentManifest;</declaration>
		<location id="id83" x="-408" y="-391">
		</location>
		<location id="id84" x="-255" y="-391">
		</location>
		<location id="id85" x="-59" y="-391">
			<name x="-42" y="-391">ROMExtRunning</name>
		</location>
		<location id="id86" x="-59" y="-289">
		</location>
		<location id="id87" x="-595" y="-289">
		</location>
		<location id="id88" x="-850" y="-289">
		</location>
		<init ref="id88"/>
		<transition>
			<source ref="id84"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="-382" y="-416">FinalJumpReturn!</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id84"/>
			<label kind="synchronisation" x="-221" y="-416">Rom_Ext_Fail?</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id85"/>
			<label kind="synchronisation" x="-51" y="-348">RomExtStart[currentManifest.entryPoint]!</label>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id86"/>
			<label kind="synchronisation" x="-578" y="-314">TryExecuteMemory[currentManifest.entryPoint][currentManifest.entryPoint + 4]!</label>
			<label kind="assignment" x="-577" y="-289">clearGlobalManifest()</label>
		</transition>
		<transition>
			<source ref="id88"/>
			<target ref="id87"/>
			<label kind="synchronisation" x="-833" y="-348">FinalJumpCallBC?</label>
			<label kind="assignment" x="-833" y="-331">currentManifest = GlobalManifest</label>
		</transition>
	</template>
	<template>
		<name>CheckPubKeyValid</name>
		<declaration>pub_key_t publicKey;
int[-1,1] pubKeyIdList[NumberOfKeysInWhitelist] = {-1};
int[0,1] currentPubKeyId;

bool checkPublicKey(){
    int i;

    for(i = 0; i &lt; NumberOfKeysInWhitelist; i++)    
        if (pubKeyIdList[i] == currentPubKeyId)
                return true;
    return false;
}

void calculateKeyId(){
    if(publicKey.exponent == 1 &amp;&amp; publicKey.modulus == 1)
        currentPubKeyId = 1;
    else
        currentPubKeyId = 0;
}</declaration>
		<location id="id89" x="-459" y="-289">
		</location>
		<location id="id90" x="246" y="-289">
		</location>
		<location id="id91" x="-68" y="-289">
		</location>
		<location id="id92" x="-255" y="-289">
		</location>
		<location id="id93" x="-799" y="-289">
		</location>
		<location id="id94" x="-595" y="-289">
		</location>
		<init ref="id93"/>
		<transition>
			<source ref="id89"/>
			<target ref="id92"/>
			<label kind="synchronisation" x="-441" y="-306">CheckSRAMReturn?</label>
			<label kind="assignment" x="-441" y="-289">publicKey = GlobalPublicKey,
clearGlobalPublicKey()</label>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id89"/>
			<label kind="synchronisation" x="-578" y="-314">CheckSRAM[4]!</label>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id90"/>
			<label kind="synchronisation" x="-34" y="-314">ReadMemoryReturn?</label>
			<label kind="assignment" x="-51" y="-289">pubKeyIdList = GlobalPublicKeyIdWhitelist,
clearGlobalPubKeyWhitelist(),
calculateKeyId(),
clearGlobalPublicKey()</label>
		</transition>
		<transition>
			<source ref="id92"/>
			<target ref="id91"/>
			<label kind="synchronisation" x="-238" y="-314">ReadMemory[13][13]!</label>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id93"/>
			<label kind="guard" x="-187" y="-382">!checkPublicKey()</label>
			<label kind="synchronisation" x="-187" y="-365">PubKeyNotValidBC!</label>
			<nail x="246" y="-340"/>
			<nail x="-799" y="-340"/>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id93"/>
			<label kind="guard" x="-170" y="-187">checkPublicKey()</label>
			<label kind="synchronisation" x="-170" y="-170">PubKeyValidBC!</label>
			<nail x="246" y="-204"/>
			<nail x="-799" y="-204"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id94"/>
			<label kind="synchronisation" x="-790" y="-314">CheckPublicKeyValidCallBC?</label>
		</transition>
	</template>
	<template>
		<name>OTBN</name>
		<declaration>int signature;
int digest;
pub_key_t key;

bool checkSignature(){
    return signature == 1 &amp;&amp; digest == 3 &amp;&amp; 
    key.modulus == 1 &amp;&amp; key.exponent == 1;     //Signature is valid and correct image code is hashed
}

void clear(){
    key.exponent = 0;
    key.modulus = 0;
    signature = 0;
    digest = 0;  
}
</declaration>
		<location id="id95" x="-833" y="-459">
		</location>
		<location id="id96" x="-935" y="-459">
		</location>
		<location id="id97" x="-1105" y="-459">
		</location>
		<location id="id98" x="-1241" y="-459">
		</location>
		<location id="id99" x="-1684" y="-460">
		</location>
		<location id="id100" x="-663" y="-459">
		</location>
		<location id="id101" x="-1395" y="-460">
		</location>
		<location id="id102" x="-1531" y="-460">
		</location>
		<init ref="id99"/>
		<transition>
			<source ref="id95"/>
			<target ref="id100"/>
			<label kind="synchronisation" x="-816" y="-442">CheckSRAMReturn?</label>
			<label kind="assignment" x="-816" y="-425">key = GlobalPublicKey,
clearGlobalPublicKey()</label>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id95"/>
			<label kind="synchronisation" x="-935" y="-501">CheckSRAM[4]!</label>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id96"/>
			<label kind="synchronisation" x="-1071" y="-450">CheckSRAMReturn?</label>
			<label kind="assignment" x="-1079" y="-433">digest = GlobalDigest,
GlobalDigest = 0</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id97"/>
			<label kind="synchronisation" x="-1232" y="-484">CheckSRAM[1]!</label>
		</transition>
		<transition>
			<source ref="id101"/>
			<target ref="id98"/>
			<label kind="synchronisation" x="-1386" y="-451">CheckSRAMReturn?</label>
			<label kind="assignment" x="-1386" y="-434">signature = GlobalSignature,
GlobalSignature = 0</label>
		</transition>
		<transition>
			<source ref="id102"/>
			<target ref="id101"/>
			<label kind="synchronisation" x="-1531" y="-494">CheckSRAM[5]!</label>
		</transition>
		<transition>
			<source ref="id99"/>
			<target ref="id102"/>
			<label kind="synchronisation" x="-1675" y="-451">CheckSignatureBC?</label>
		</transition>
		<transition>
			<source ref="id100"/>
			<target ref="id99"/>
			<label kind="guard" x="-841" y="-586">!checkSignature()</label>
			<label kind="synchronisation" x="-841" y="-569">RSANotValidBC!</label>
			<label kind="assignment" x="-841" y="-552">clear()</label>
			<nail x="-663" y="-484"/>
			<nail x="-663" y="-527"/>
			<nail x="-1684" y="-528"/>
		</transition>
		<transition>
			<source ref="id100"/>
			<target ref="id99"/>
			<label kind="guard" x="-858" y="-323">checkSignature()</label>
			<label kind="synchronisation" x="-858" y="-306">RSAValidBC!</label>
			<label kind="assignment" x="-858" y="-289">clear()</label>
			<nail x="-663" y="-340"/>
			<nail x="-1684" y="-341"/>
		</transition>
	</template>
	<template>
		<name>ValidityCheckObserver</name>
		<declaration>//Fix guards in accordance to new key make up</declaration>
		<location id="id103" x="391" y="-51">
			<name x="381" y="-85">Success</name>
		</location>
		<location id="id104" x="187" y="-51">
		</location>
		<location id="id105" x="-51" y="-51">
		</location>
		<location id="id106" x="-289" y="-51">
		</location>
		<location id="id107" x="-51" y="51">
			<committed/>
		</location>
		<init ref="id106"/>
		<transition>
			<source ref="id107"/>
			<target ref="id106"/>
			<nail x="-289" y="51"/>
		</transition>
		<transition>
			<source ref="id104"/>
			<target ref="id107"/>
			<label kind="guard" x="-25" y="8">GlobalSignature != 33</label>
			<label kind="synchronisation" x="-25" y="25">SignatureNotValidBC?</label>
			<nail x="187" y="51"/>
		</transition>
		<transition>
			<source ref="id105"/>
			<target ref="id107"/>
			<label kind="synchronisation" x="-229" y="0">PubKeyNotValidBC?</label>
		</transition>
		<transition>
			<source ref="id104"/>
			<target ref="id103"/>
			<label kind="guard" x="205" y="-85">GlobalSignature == 33</label>
			<label kind="synchronisation" x="204" y="-102">SignatureValid?</label>
		</transition>
		<transition>
			<source ref="id105"/>
			<target ref="id104"/>
			<label kind="synchronisation" x="-25" y="-76">PubKeyValidBC?</label>
		</transition>
		<transition>
			<source ref="id106"/>
			<target ref="id105"/>
			<label kind="select" x="-263" y="-127">e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-263" y="-110">e != 0</label>
			<label kind="synchronisation" x="-263" y="-93">RomExtValidBC[e]?</label>
		</transition>
	</template>
	<template>
		<name>PmpModuleOld</name>
		<declaration>int start, end;

void initializePmp(){
    PmpRegions[15].startAddress = 0;
    PmpRegions[15].endAddress = MemoryMaxIndex;
    PmpRegions[15].write = false;
    PmpRegions[15].read = true;
    PmpRegions[15].execute = false;
    PmpRegions[15].locked = true;
}
bool canRead(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].read)
                return true;
    return false;
}

bool canWrite(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].write)
                return true;
    return false;
}

bool canExecute(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].execute)
                return true;
    return false;
}</declaration>
		<location id="id108" x="-204" y="-340">
		</location>
		<location id="id109" x="-136" y="-510">
		</location>
		<location id="id110" x="-34" y="-340">
			<committed/>
		</location>
		<location id="id111" x="-382" y="-340">
			<committed/>
		</location>
		<init ref="id109"/>
		<transition>
			<source ref="id111"/>
			<target ref="id108"/>
			<label kind="synchronisation" x="-493" y="-297">PmpReadMemory[start][end]!</label>
			<label kind="assignment" x="-493" y="-280">start = 0,
end = 0</label>
			<nail x="-382" y="-306"/>
			<nail x="-238" y="-306"/>
		</transition>
		<transition>
			<source ref="id110"/>
			<target ref="id108"/>
			<label kind="synchronisation" x="-51" y="-297">PmpWriteMemory[start][end]!</label>
			<label kind="assignment" x="-51" y="-280">start = 0,
end = 0</label>
			<nail x="-34" y="-306"/>
			<nail x="-170" y="-306"/>
		</transition>
		<transition>
			<source ref="id108"/>
			<target ref="id108"/>
			<label kind="select" x="-272" y="-238">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-272" y="-204">canExecute(s,e)</label>
			<label kind="synchronisation" x="-272" y="-187">TryExecuteMemory[s][e]?</label>
			<nail x="-221" y="-272"/>
			<nail x="-187" y="-272"/>
		</transition>
		<transition>
			<source ref="id108"/>
			<target ref="id110"/>
			<label kind="select" x="-17" y="-450">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-17" y="-416">canWrite(s,e)</label>
			<label kind="synchronisation" x="-17" y="-399">TryWriteMemory[s][e]?</label>
			<label kind="assignment" x="-17" y="-382">start = s,
end = e</label>
			<nail x="-178" y="-374"/>
			<nail x="-34" y="-374"/>
		</transition>
		<transition>
			<source ref="id108"/>
			<target ref="id111"/>
			<label kind="select" x="-484" y="-459">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-484" y="-425">canRead(s, e)</label>
			<label kind="synchronisation" x="-484" y="-408">TryReadMemory[s][e]?</label>
			<label kind="assignment" x="-484" y="-391">start = s,
end = e</label>
			<nail x="-238" y="-374"/>
			<nail x="-382" y="-374"/>
		</transition>
		<transition>
			<source ref="id109"/>
			<target ref="id108"/>
			<label kind="synchronisation" x="-238" y="-501">PowerOnBC?</label>
			<label kind="assignment" x="-238" y="-484">initializePmp()</label>
			<nail x="-238" y="-510"/>
			<nail x="-238" y="-442"/>
			<nail x="-136" y="-442"/>
			<nail x="-136" y="-408"/>
			<nail x="-204" y="-408"/>
		</transition>
	</template>
	<template>
		<name>PmpModule</name>
		<declaration>int start, end;

void initializePmp(){
    PmpRegions[15].startAddress = 0;
    PmpRegions[15].endAddress = MemoryMaxIndex;
    PmpRegions[15].write = false;
    PmpRegions[15].read = true;
    PmpRegions[15].execute = false;
    PmpRegions[15].locked = true;
}
bool canRead(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].read)
                return true;
    return false;
}

bool canWrite(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].write)
                return true;
    return false;
}

bool canExecute(int startIndex, int endIndex){
    int i;
    for(i = 0; i &lt; 16;i++)
        if (PmpRegions[i].startAddress &lt;= startIndex &amp;&amp; PmpRegions[i].endAddress &gt;= endIndex)
            if (PmpRegions[i].execute)
                return true;
    return false;
}</declaration>
		<location id="id112" x="-204" y="-340">
			<name x="-212" y="-314">Idle</name>
		</location>
		<location id="id113" x="-238" y="-493">
			<name x="-248" y="-527">Initial</name>
		</location>
		<location id="id114" x="136" y="-340">
			<name x="153" y="-357">WritingMemory</name>
			<committed/>
		</location>
		<location id="id115" x="-544" y="-340">
			<name x="-671" y="-357">ReadingMemory</name>
			<committed/>
		</location>
		<location id="id116" x="-85" y="-153">
			<name x="-68" y="-153">BadExecute</name>
			<committed/>
		</location>
		<location id="id117" x="-391" y="-340">
			<name x="-425" y="-323">BadRead</name>
			<committed/>
		</location>
		<location id="id118" x="-17" y="-340">
			<name x="-42" y="-331">BadWrite</name>
			<committed/>
		</location>
		<location id="id119" x="-493" y="-204">
			<name x="-527" y="-187">GoodRead</name>
			<committed/>
		</location>
		<location id="id120" x="85" y="-204">
			<name x="76" y="-238">GoodWrite</name>
			<committed/>
		</location>
		<location id="id121" x="-323" y="-153">
			<name x="-408" y="-144">GoodExecute</name>
			<committed/>
		</location>
		<init ref="id113"/>
		<transition>
			<source ref="id121"/>
			<target ref="id112"/>
			<label kind="assignment" x="-306" y="-136">start = 0,
end = 0</label>
			<nail x="-306" y="-136"/>
		</transition>
		<transition>
			<source ref="id114"/>
			<target ref="id120"/>
			<label kind="guard" x="144" y="-263">canWrite(start,end)</label>
			<nail x="136" y="-204"/>
		</transition>
		<transition>
			<source ref="id119"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-476" y="-263">PmpReadMemory[start][end]!</label>
			<label kind="assignment" x="-476" y="-246">start = 0,
end = 0</label>
			<nail x="-340" y="-204"/>
		</transition>
		<transition>
			<source ref="id118"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-161" y="-357">RaiseExceptionBC!</label>
		</transition>
		<transition>
			<source ref="id117"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-365" y="-357">RaiseExceptionBC!</label>
		</transition>
		<transition>
			<source ref="id116"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-68" y="-187">RaiseExceptionBC!</label>
			<nail x="-68" y="-170"/>
		</transition>
		<transition>
			<source ref="id112"/>
			<target ref="id116"/>
			<label kind="select" x="-195" y="-136">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-195" y="-102">!canExecute(s,e)</label>
			<label kind="synchronisation" x="-195" y="-85">TryExecuteMemory[s][e]?</label>
			<nail x="-102" y="-136"/>
		</transition>
		<transition>
			<source ref="id114"/>
			<target ref="id118"/>
			<label kind="guard" x="0" y="-399">!canWrite(start,end)</label>
			<label kind="assignment" x="0" y="-382">start = 0,
end = 0</label>
		</transition>
		<transition>
			<source ref="id115"/>
			<target ref="id117"/>
			<label kind="guard" x="-518" y="-399">!canRead(start,end)</label>
			<label kind="assignment" x="-518" y="-382">start = 0,
end = 0</label>
		</transition>
		<transition>
			<source ref="id115"/>
			<target ref="id119"/>
			<label kind="guard" x="-671" y="-263">canRead(start, end)</label>
			<nail x="-544" y="-204"/>
		</transition>
		<transition>
			<source ref="id120"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-59" y="-263">PmpWriteMemory[start][end]!</label>
			<label kind="assignment" x="-59" y="-246">start = 0,
end = 0</label>
			<nail x="-68" y="-204"/>
		</transition>
		<transition>
			<source ref="id112"/>
			<target ref="id121"/>
			<label kind="select" x="-535" y="-127">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="guard" x="-535" y="-93">canExecute(s,e)</label>
			<label kind="synchronisation" x="-535" y="-76">TryExecuteMemory[s][e]?</label>
			<label kind="assignment" x="-535" y="-59">start = s,
end = e</label>
			<nail x="-340" y="-170"/>
		</transition>
		<transition>
			<source ref="id112"/>
			<target ref="id114"/>
			<label kind="select" x="17" y="-535">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="59" y="-501">TryWriteMemory[s][e]?</label>
			<label kind="assignment" x="144" y="-484">start = s,
end = e</label>
			<nail x="-68" y="-476"/>
			<nail x="136" y="-476"/>
		</transition>
		<transition>
			<source ref="id112"/>
			<target ref="id115"/>
			<label kind="select" x="-688" y="-518">s : int[0,MemoryMaxIndex - 1],
e : int[0,MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-688" y="-484">TryReadMemory[s][e]?</label>
			<label kind="assignment" x="-688" y="-467">start = s,
end = e</label>
			<nail x="-340" y="-476"/>
			<nail x="-544" y="-476"/>
		</transition>
		<transition>
			<source ref="id113"/>
			<target ref="id112"/>
			<label kind="synchronisation" x="-229" y="-484">PowerOnBC?</label>
			<label kind="assignment" x="-229" y="-467">initializePmp()</label>
			<nail x="-238" y="-467"/>
			<nail x="-238" y="-459"/>
			<nail x="-238" y="-442"/>
			<nail x="-204" y="-442"/>
			<nail x="-204" y="-408"/>
		</transition>
	</template>
	<template>
		<name>FlashController</name>
		<declaration>int startIndex, endIndex;
int scramblingKey;

void unscramble(){
    if (scramblingKey == 2) 
        GlobalMemoryIsScrambled = false;
}

</declaration>
		<location id="id122" x="51" y="-17">
		</location>
		<location id="id123" x="51" y="-85">
		</location>
		<location id="id124" x="-119" y="-51">
			<name x="-153" y="-85">Idle</name>
		</location>
		<location id="id125" x="-595" y="-51">
			<committed/>
		</location>
		<location id="id126" x="-595" y="102">
			<name x="-654" y="68">Reading</name>
		</location>
		<location id="id127" x="-119" y="-221">
		</location>
		<location id="id128" x="-119" y="-153">
		</location>
		<location id="id129" x="-119" y="59">
			<name x="-93" y="51">ScrambleCheck</name>
			<committed/>
		</location>
		<init ref="id127"/>
		<transition>
			<source ref="id129"/>
			<target ref="id124"/>
		</transition>
		<transition>
			<source ref="id128"/>
			<target ref="id124"/>
			<label kind="synchronisation" x="-348" y="-144">ReturnFlashScramblingKey?</label>
			<label kind="assignment" x="-348" y="-127">scramblingKey = GlobalOTPStorage,
GlobalOTPStorage = 0</label>
		</transition>
		<transition>
			<source ref="id127"/>
			<target ref="id128"/>
			<label kind="synchronisation" x="-306" y="-204">RequestFlashScramblingKey!</label>
		</transition>
		<transition>
			<source ref="id126"/>
			<target ref="id129"/>
			<label kind="guard" x="-357" y="8">!GlobalMemoryIsScrambled</label>
			<label kind="synchronisation" x="-357" y="25">FlashReadReturn!</label>
			<label kind="assignment" x="-357" y="42">startIndex = 0,
endIndex = 0</label>
			<nail x="-578" y="85"/>
			<nail x="-136" y="85"/>
		</transition>
		<transition>
			<source ref="id122"/>
			<target ref="id124"/>
			<label kind="assignment" x="-85" y="-25">startIndex = 0,
endIndex = 0</label>
		</transition>
		<transition>
			<source ref="id123"/>
			<target ref="id122"/>
			<label kind="synchronisation" x="51" y="-68">TryWriteMemory[startIndex][endIndex]!</label>
		</transition>
		<transition>
			<source ref="id124"/>
			<target ref="id123"/>
			<label kind="select" x="-42" y="-187">s : int[0, MemoryMaxIndex - 1],
e : int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-42" y="-153">FlashWrite[s][e]?</label>
			<label kind="assignment" x="-42" y="-136">startIndex = s,
endIndex = e</label>
		</transition>
		<transition>
			<source ref="id126"/>
			<target ref="id129"/>
			<label kind="guard" x="-357" y="110">GlobalMemoryIsScrambled</label>
			<label kind="synchronisation" x="-357" y="127">FlashReadReturn!</label>
			<label kind="assignment" x="-357" y="144">unscramble(),
startIndex = 0,
endIndex = 0</label>
			<nail x="-119" y="102"/>
		</transition>
		<transition>
			<source ref="id125"/>
			<target ref="id126"/>
			<label kind="synchronisation" x="-841" y="0">TryReadMemory[startIndex][endIndex]!</label>
		</transition>
		<transition>
			<source ref="id124"/>
			<target ref="id125"/>
			<label kind="select" x="-586" y="-153">s : int[0, MemoryMaxIndex - 1],
e : int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-586" y="-119">FlashRead[s][e]?</label>
			<label kind="assignment" x="-586" y="-102">startIndex = s,
endIndex = e</label>
		</transition>
	</template>
	<template>
		<name>ExceptionHandler</name>
		<location id="id130" x="-102" y="-102">
			<name x="-85" y="-136">ExceptionRaised</name>
			<committed/>
		</location>
		<location id="id131" x="-238" y="-102">
		</location>
		<init ref="id131"/>
		<transition>
			<source ref="id131"/>
			<target ref="id130"/>
			<label kind="synchronisation" x="-212" y="-68">NotInSRAM?</label>
			<nail x="-170" y="-68"/>
		</transition>
		<transition>
			<source ref="id131"/>
			<target ref="id130"/>
			<label kind="synchronisation" x="-229" y="-161">RaiseExceptionBC?</label>
			<nail x="-170" y="-136"/>
		</transition>
	</template>
	<template>
		<name>LifeCycleController</name>
		<declaration>life_cycle_state_t currentState = {0, 0, 0, 0, 0};
life_cycle_state_t correctState = {54, 9, -2, 11, 27};
int lifeCycleState = 0;

void deriveLifeCycleState(){
    if (lifeCycleState = 1)
        currentState = correctState;

}</declaration>
		<location id="id132" x="-170" y="-34">
			<committed/>
		</location>
		<location id="id133" x="-68" y="-34">
		</location>
		<location id="id134" x="-272" y="-34">
		</location>
		<location id="id135" x="-272" y="-187">
			<name x="-297" y="-221">RAW</name>
		</location>
		<location id="id136" x="-68" y="-187">
		</location>
		<init ref="id134"/>
		<transition>
			<source ref="id136"/>
			<target ref="id133"/>
			<label kind="synchronisation" x="-51" y="-144">ReturnLifeCyclePartition?</label>
			<label kind="assignment" x="-51" y="-127">lifeCycleState = GlobalOTPStorage,
GlobalOTPStorage = 0,
deriveLifeCycleState()</label>
		</transition>
		<transition>
			<source ref="id135"/>
			<target ref="id136"/>
			<label kind="synchronisation" x="-255" y="-212">RequestLifeCyclePartition!</label>
		</transition>
		<transition>
			<source ref="id134"/>
			<target ref="id135"/>
			<label kind="synchronisation" x="-357" y="-119">PowerOnBC?</label>
		</transition>
		<transition>
			<source ref="id132"/>
			<target ref="id133"/>
			<label kind="synchronisation" x="-153" y="0">ReturnLifeCycleState!</label>
			<label kind="assignment" x="-153" y="17">GlobalLifeCycleState = currentState</label>
			<nail x="-119" y="-8"/>
		</transition>
		<transition>
			<source ref="id133"/>
			<target ref="id132"/>
			<label kind="synchronisation" x="-238" y="-93">RequestLifeCycleState?</label>
			<nail x="-119" y="-59"/>
		</transition>
	</template>
	<template>
		<name>HMAC</name>
		<declaration>
int secretKey = 0; // burde komme fra KM.
int Opad;
int Ipad;
int loopIndex = 0;
int message;

int[0,4] Progress = 0;


void calculateOuterPadding(){
}

void calculateInnerPadding(){
}

void calculateMessagePadding(){

}

void breakIntoChunks(){
}

void hash(){ //Might want another approach since hash is called multiple times per run of HMAC.
    if(message == 1 || message == 3)
        message = 3; //Hash of the correct image code
    else
        message = 4; //Hash of an inccorect image code
}

void wipeSecretKey(int num){
    if (num == 1)
        secretKey = 0;
}
bool my_xor(bool a, bool b){
    return a != b;
}
/*
void calculateOPad(){
    //o_key_pad = secretKey xor [0x5c * blockSize / 8]    Outer padded key
    int i;
    for(i = 0; i &lt; blockSize / 8; i++)
    {
        oPad[i] = my_xor(secretKey[i],0);
        oPad[i+1] = my_xor(secretKey[i+1],1);
        oPad[i+2] = my_xor(secretKey[i+2],0);
        oPad[i+3] = my_xor(secretKey[i+3],1);
        oPad[i+4] = my_xor(secretKey[i+4],1);
        oPad[i+5] = my_xor(secretKey[i+5],1);
        oPad[i+6] = my_xor(secretKey[i+6],0);
        oPad[i+7] = my_xor(secretKey[i+7],0);
    }
}

void calculateIPad(){
    //i_key_pad = secretKey xor [0x36 * blockSize / 8]   // Inner padded key
    int i;
    for(i = 0; i &lt; blockSize / 8; i++)
    {
        iPad[i] = my_xor(secretKey[i],0);
        iPad[i+1] = my_xor(secretKey[i+1],0);
        iPad[i+2] = my_xor(secretKey[i+2],1);
        iPad[i+3] = my_xor(secretKey[i+3],1);
        iPad[i+4] = my_xor(secretKey[i+4],0);
        iPad[i+5] = my_xor(secretKey[i+5],1);
        iPad[i+6] = my_xor(secretKey[i+6],1);
        iPad[i+7] = my_xor(secretKey[i+7],0);
    }
}
/*
void hash(int size) // Takes and returns a bit array
{
    int i;
    for (i = 0; i &lt; outputSize; i++)
    {
        result[i] = intermediateResult[i];
    }
}
*/
/*
void HMAC() // Assuming the key is always exactly 512 bits long.
{
    int i;
    calculateOPad();
    calculateIPad();
    
    //hash(o_key_pad ∥ hash(i_key_pad ∥ message))

    
    for(i = 0; i &lt; blockSize; i++)
    {
        intermediateResult[i] = iPad[i];
        intermediateResult[i + blockSize] = message[i];
    }
    hash(blockSize * 2);
    
    for(i = 0; i &lt; blockSize; i++)
    {
        intermediateResult[i] = oPad[i];
        if (i &lt; outputSize)
            intermediateResult[i + blockSize] = result[i];
    }
    
    hash(outputSize + blockSize);
}*/</declaration>
		<location id="id137" x="-952" y="-408">
		</location>
		<location id="id138" x="-510" y="-170">
		</location>
		<location id="id139" x="-952" y="-170">
		</location>
		<location id="id140" x="-510" y="-408">
		</location>
		<location id="id141" x="-510" y="-323">
		</location>
		<location id="id142" x="-952" y="-289">
		</location>
		<location id="id143" x="-824" y="-170">
		</location>
		<location id="id144" x="-688" y="-170">
		</location>
		<init ref="id139"/>
		<transition>
			<source ref="id144"/>
			<target ref="id143"/>
			<label kind="synchronisation" x="-816" y="-212">WriteMemoryReturn?</label>
		</transition>
		<transition>
			<source ref="id138"/>
			<target ref="id144"/>
			<label kind="guard" x="-646" y="-195">loopIndex &gt;= 2</label>
			<label kind="synchronisation" x="-663" y="-161">WriteMemory!</label>
			<label kind="assignment" x="-663" y="-144">GlobalDigest = message</label>
		</transition>
		<transition>
			<source ref="id137"/>
			<target ref="id140"/>
			<label kind="synchronisation" x="-901" y="-476">CheckSRAMReturn?</label>
			<label kind="assignment" x="-909" y="-459">message = GlobalImageCode,
GlobalImageCode = 0</label>
		</transition>
		<transition>
			<source ref="id142"/>
			<target ref="id137"/>
			<label kind="synchronisation" x="-1062" y="-357">CheckSRAM[2]!</label>
		</transition>
		<transition>
			<source ref="id141"/>
			<target ref="id138"/>
			<label kind="synchronisation" x="-484" y="-314">ReturnSecretKey?</label>
			<label kind="assignment" x="-510" y="-289">secretKey = GlobalSecretKey,
GlobalSecretKey = 0,
Progress = 1</label>
		</transition>
		<transition>
			<source ref="id140"/>
			<target ref="id141"/>
			<label kind="synchronisation" x="-484" y="-382">RequestSecretKey!</label>
		</transition>
		<transition>
			<source ref="id138"/>
			<target ref="id138"/>
			<label kind="guard" x="-356" y="-204">loopIndex &lt; 2</label>
			<label kind="assignment" x="-357" y="-187">calculateMessagePadding(),
breakIntoChunks(),
hash(),
loopIndex += 1,
Progress += 1</label>
			<nail x="-442" y="-238"/>
			<nail x="-374" y="-170"/>
			<nail x="-442" y="-102"/>
		</transition>
		<transition>
			<source ref="id143"/>
			<target ref="id139"/>
			<label kind="select" x="-918" y="-136">i : int[0,1]</label>
			<label kind="synchronisation" x="-918" y="-102">HMACReturn!</label>
			<label kind="assignment" x="-918" y="-85">loopIndex = 0,
wipeSecretKey(i),
Progress = 4</label>
		</transition>
		<transition>
			<source ref="id139"/>
			<target ref="id142"/>
			<label kind="synchronisation" x="-1181" y="-212">HMACCalled?</label>
			<label kind="assignment" x="-1181" y="-195">calculateInnerPadding(),
calculateOuterPadding(),
Progress = 0</label>
		</transition>
	</template>
	<template>
		<name>KeyManager</name>
		<declaration>// Contains keys
// derives keys from other keys and seeds
// makes keys visible to certain other SW components.

life_cycle_state_t LifeCycleState;

int[0,3] InternalState;
// 0 -&gt; reset
// 1 -&gt; Initialized
// 2 -&gt; CreatorRootKey
// 3 -&gt; RomExt Running

int entropy;

int rootKey = 0; // Documentation says it is in OTP, so maybe it does not belong here.
int CreatorRootKey = -1;
void deriveSecretKey(){
    
}

</declaration>
		<location id="id145" x="-637" y="-306">
		</location>
		<location id="id146" x="-467" y="-144">
			<name x="-450" y="-170">OwnerIntermediateKey</name>
			<label kind="comments" x="-450" y="-144">Derive more keys, but this is out of scope</label>
		</location>
		<location id="id147" x="-467" y="-272">
			<name x="-450" y="-280">CreatorRootKeyDerived</name>
		</location>
		<location id="id148" x="-467" y="-740">
			<name x="-544" y="-748">Initialized</name>
			<committed/>
		</location>
		<location id="id149" x="-467" y="-977">
			<name x="-526" y="-985">Reset</name>
		</location>
		<location id="id150" x="-467" y="-680">
			<committed/>
		</location>
		<location id="id151" x="-467" y="-595">
		</location>
		<location id="id152" x="-467" y="-408">
			<committed/>
		</location>
		<location id="id153" x="-731" y="-272">
		</location>
		<location id="id154" x="-637" y="-238">
		</location>
		<location id="id155" x="-467" y="-493">
			<committed/>
		</location>
		<location id="id156" x="-467" y="-892">
		</location>
		<location id="id157" x="-467" y="-799">
		</location>
		<init ref="id149"/>
		<transition>
			<source ref="id157"/>
			<target ref="id148"/>
			<label kind="synchronisation" x="-408" y="-807">ReturnEDN?</label>
			<label kind="assignment" x="-408" y="-790">entropy = GlobalEntropy,
GlobalEntropy = 0</label>
		</transition>
		<transition>
			<source ref="id156"/>
			<target ref="id157"/>
			<label kind="synchronisation" x="-459" y="-850">RequestEDN!</label>
		</transition>
		<transition>
			<source ref="id151"/>
			<target ref="id155"/>
			<label kind="synchronisation" x="-450" y="-561">GetRootKeyBC?</label>
		</transition>
		<transition>
			<source ref="id153"/>
			<target ref="id154"/>
			<label kind="synchronisation" x="-799" y="-213">KMACReturn?</label>
			<nail x="-731" y="-238"/>
		</transition>
		<transition>
			<source ref="id145"/>
			<target ref="id153"/>
			<label kind="synchronisation" x="-909" y="-357">KMACCalled!</label>
			<label kind="assignment" x="-909" y="-340">GlobalSecretKey = CreatorRootKey</label>
			<nail x="-731" y="-306"/>
		</transition>
		<transition>
			<source ref="id152"/>
			<target ref="id147"/>
			<label kind="synchronisation" x="-433" y="-407">KMACReturn?</label>
			<label kind="assignment" x="-433" y="-390">CreatorRootKey = GlobalKMACResult,
GlobalKMACResult = 0</label>
		</transition>
		<transition>
			<source ref="id155"/>
			<target ref="id152"/>
			<label kind="synchronisation" x="-450" y="-467">KMACCalled!</label>
			<label kind="assignment" x="-450" y="-450">GlobalSecretKey = rootKey</label>
		</transition>
		<transition>
			<source ref="id150"/>
			<target ref="id151"/>
			<label kind="synchronisation" x="-450" y="-654">ReturnLifeCycleState?</label>
			<label kind="assignment" x="-450" y="-637">LifeCycleState = GlobalLifeCycleState</label>
		</transition>
		<transition>
			<source ref="id154"/>
			<target ref="id147"/>
			<label kind="synchronisation" x="-620" y="-238">ReturnSecretKey!</label>
			<label kind="assignment" x="-629" y="-221">GlobalSecretKey = 1</label>
			<nail x="-510" y="-238"/>
		</transition>
		<transition>
			<source ref="id147"/>
			<target ref="id145"/>
			<label kind="synchronisation" x="-620" y="-332">RequestSecretKey?</label>
			<nail x="-510" y="-306"/>
		</transition>
		<transition>
			<source ref="id147"/>
			<target ref="id146"/>
			<label kind="synchronisation" x="-450" y="-204">AdvanceKMState?</label>
		</transition>
		<transition>
			<source ref="id148"/>
			<target ref="id150"/>
			<label kind="synchronisation" x="-450" y="-722">RequestLifeCycleState!</label>
		</transition>
		<transition>
			<source ref="id149"/>
			<target ref="id156"/>
			<label kind="synchronisation" x="-450" y="-943">PowerOnBC?</label>
		</transition>
	</template>
	<template>
		<name>KMAC</name>
		<declaration>int key;
int loopIndex;
int message;
life_cycle_state_t LifeCycleState;

const int salt = 6969;

void calculateOuterPadding(){
}

void calculateInnerPadding(){
}

void calculateMessagePadding(){

}

void breakIntoChunks(){
}

void hash(){

}
void wipeSecretKey(int num){
    if (num == 1)
        key = 0;
}
int combineRegisters(){
    int result = LifeCycleState.Reg1 + LifeCycleState.Reg2 + LifeCycleState.Reg3 + LifeCycleState.Reg4 + LifeCycleState.Reg5;
    if (result == 0) // If the life cycle state is not set:
        result = (salt * key) % 34;
    else
        result = (result + key) % 34;
    return result;
}
void clearLifeCycleState(){
    LifeCycleState.Reg1 = 0;
    LifeCycleState.Reg2 = 0;
    LifeCycleState.Reg3 = 0;
    LifeCycleState.Reg4 = 0;
    LifeCycleState.Reg5 = 0;
}</declaration>
		<location id="id158" x="459" y="255">
			<committed/>
		</location>
		<location id="id159" x="323" y="255">
		</location>
		<init ref="id159"/>
		<transition>
			<source ref="id158"/>
			<target ref="id158"/>
			<label kind="guard" x="613" y="221">loopIndex &lt; 2</label>
			<label kind="assignment" x="612" y="238">breakIntoChunks(),
hash(),
loopIndex += 1</label>
			<label kind="comments" x="612" y="204">Number of loops could be set to 24 to simulate real-life</label>
			<nail x="527" y="187"/>
			<nail x="595" y="255"/>
			<nail x="527" y="323"/>
		</transition>
		<transition>
			<source ref="id158"/>
			<target ref="id159"/>
			<label kind="select" x="297" y="340">i : int[0,1]</label>
			<label kind="guard" x="297" y="357">loopIndex &gt;= 2</label>
			<label kind="synchronisation" x="297" y="374">KMACReturn!</label>
			<label kind="assignment" x="297" y="391">loopIndex = 0,
wipeSecretKey(i),
GlobalKMACResult = message,
clearLifeCycleState()</label>
			<nail x="391" y="323"/>
		</transition>
		<transition>
			<source ref="id159"/>
			<target ref="id158"/>
			<label kind="synchronisation" x="297" y="76">KMACCalled?</label>
			<label kind="assignment" x="297" y="93">key = GlobalSecretKey,
LifeCycleState = GlobalLifeCycleState,
message = combineRegisters(),
GlobalSecretKey = 0</label>
			<nail x="391" y="187"/>
		</transition>
	</template>
	<template>
		<name>ManifestObserver</name>
		<declaration>rom_ext_manifest_t manifest;
rom_ext_manifest_t manifest2;
pub_key_t key;
int[0,2] signature;
int[0,2] image_code;</declaration>
		<location id="id160" x="-170" y="255">
			<name x="-246" y="280">CheckingSecondManifest</name>
			<committed/>
		</location>
		<location id="id161" x="68" y="255" color="#00ff00">
			<name x="85" y="246">Success</name>
		</location>
		<location id="id162" x="-340" y="-51" color="#ff0000">
			<name x="-323" y="-59">Failure</name>
		</location>
		<location id="id163" x="-170" y="-136">
			<name x="-153" y="-144">CheckingKey</name>
			<committed/>
		</location>
		<location id="id164" x="-170" y="-221">
			<name x="-153" y="-247">CheckingRomExtManifest</name>
		</location>
		<location id="id165" x="-170" y="-306">
			<name x="-212" y="-340">Initial</name>
		</location>
		<location id="id166" x="-170" y="-51">
			<name x="-153" y="-76">AwaitingSignature</name>
		</location>
		<location id="id167" x="-170" y="68">
			<name x="-153" y="59">CheckingSignature</name>
			<committed/>
		</location>
		<location id="id168" x="-170" y="170">
		</location>
		<init ref="id165"/>
		<transition>
			<source ref="id168"/>
			<target ref="id165"/>
			<label kind="synchronisation" x="93" y="68">SignatureNotValidBC?</label>
			<nail x="238" y="170"/>
			<nail x="238" y="-357"/>
			<nail x="-170" y="-357"/>
		</transition>
		<transition>
			<source ref="id166"/>
			<target ref="id165"/>
			<label kind="synchronisation" x="85" y="-144">PubKeyNotValidBC?</label>
			<nail x="76" y="-51"/>
			<nail x="76" y="-306"/>
		</transition>
		<transition>
			<source ref="id164"/>
			<target ref="id165"/>
			<label kind="synchronisation" x="-510" y="-272">CheckRomExtManifestNotValidBC?</label>
			<nail x="-272" y="-221"/>
			<nail x="-272" y="-306"/>
		</transition>
		<transition>
			<source ref="id160"/>
			<target ref="id162"/>
			<label kind="guard" x="-467" y="229">manifest2 != manifest</label>
			<nail x="-476" y="255"/>
			<nail x="-476" y="-51"/>
		</transition>
		<transition>
			<source ref="id160"/>
			<target ref="id161"/>
			<label kind="guard" x="-127" y="255">manifest2 == manifest</label>
		</transition>
		<transition>
			<source ref="id168"/>
			<target ref="id160"/>
			<label kind="synchronisation" x="-161" y="187">FinalJumpCallBC?</label>
			<label kind="assignment" x="-161" y="204">manifest2 = GlobalManifest</label>
		</transition>
		<transition>
			<source ref="id167"/>
			<target ref="id168"/>
			<label kind="guard" x="-161" y="110">signature == manifest.signature &amp;&amp;
image_code == manifest.image_code</label>
		</transition>
		<transition>
			<source ref="id167"/>
			<target ref="id162"/>
			<label kind="guard" x="-416" y="68">signature != manifest.signature ||
image_code != manifest.image_code</label>
			<nail x="-340" y="68"/>
		</transition>
		<transition>
			<source ref="id166"/>
			<target ref="id167"/>
			<label kind="synchronisation" x="-170" y="-17">VerifyRomExtSignatureCallBC?</label>
			<label kind="assignment" x="-169" y="0">image_code = GlobalManifest.image_code,
signature = GlobalManifest.signature</label>
		</transition>
		<transition>
			<source ref="id163"/>
			<target ref="id162"/>
			<label kind="guard" x="-518" y="-144">manifest.publicKey != key</label>
			<nail x="-340" y="-136"/>
		</transition>
		<transition>
			<source ref="id163"/>
			<target ref="id166"/>
			<label kind="guard" x="-161" y="-110">manifest.publicKey == key</label>
		</transition>
		<transition>
			<source ref="id164"/>
			<target ref="id163"/>
			<label kind="synchronisation" x="-161" y="-195">ReadPublicKeyCallBC?</label>
			<label kind="assignment" x="-161" y="-178">key = GlobalManifest.publicKey</label>
		</transition>
		<transition>
			<source ref="id165"/>
			<target ref="id164"/>
			<label kind="synchronisation" x="-161" y="-289">CheckRomExtManifestCallBC?</label>
			<label kind="assignment" x="-160" y="-272">manifest = GlobalManifest</label>
		</transition>
	</template>
	<template>
		<name>SRAMController</name>
		<declaration>int scrambleKey;
int index;
const int SRAMSize = MemoryMaxIndex / 20;

void scramble(){
    GlobalMemoryIsScrambled = true;
}

void unscramble(){
    GlobalMemoryIsScrambled = false;
}

bool publicKeyEquals(pub_key_t key1, pub_key_t key2){
    return key1.modulus == key2.modulus &amp;&amp;
           key1.exponent == key2.exponent;
}

bool manifestEquals(rom_ext_manifest_t manifest1, rom_ext_manifest_t manifest2){
    return manifest1.identifier == manifest2.identifier &amp;&amp;
           manifest1.image_code == manifest2.image_code &amp;&amp;
           manifest1.signature == manifest2.signature &amp;&amp;
           publicKeyEquals(manifest1.publicKey, manifest2.publicKey) &amp;&amp;
           manifest1.entryPoint == manifest2.entryPoint;
}

bool bootPolicyEquals(boot_policy_t bootPolicy1, boot_policy_t bootPolicy2){
    return bootPolicy1.identifier == bootPolicy2.identifier &amp;&amp;
           bootPolicy1.rom_ext_slot[0] == bootPolicy2.rom_ext_slot[0] &amp;&amp;
           bootPolicy1.fail_function_address == bootPolicy2.fail_function_address &amp;&amp;
           bootPolicy1.rom_ext_failure_function_address == bootPolicy2.rom_ext_failure_function_address;
}
</declaration>
		<location id="id169" x="357" y="280">
		</location>
		<location id="id170" x="357" y="238">
		</location>
		<location id="id171" x="-272" y="-221">
			<committed/>
		</location>
		<location id="id172" x="357" y="204">
		</location>
		<location id="id173" x="170" y="119">
		</location>
		<location id="id174" x="-34" y="0">
			<name x="-25" y="8">Idle</name>
		</location>
		<location id="id175" x="-272" y="0">
		</location>
		<location id="id176" x="-153" y="-119">
		</location>
		<location id="id177" x="-34" y="-221">
			<name x="-25" y="-255">ScrambleCheck</name>
		</location>
		<location id="id178" x="357" y="34">
		</location>
		<location id="id179" x="357" y="68">
		</location>
		<location id="id180" x="357" y="102">
		</location>
		<location id="id181" x="357" y="136">
		</location>
		<location id="id182" x="357" y="170">
		</location>
		<location id="id183" x="578" y="119">
			<committed/>
		</location>
		<location id="id184" x="-425" y="0">
		</location>
		<init ref="id184"/>
		<transition>
			<source ref="id169"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="375" y="263">WritePublicKeyIdWhitelistToSRAM!</label>
			<nail x="552" y="280"/>
			<nail x="578" y="212"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id169"/>
			<label kind="synchronisation" x="161" y="263">WritePublicKeyIdWhitelist?</label>
			<nail x="204" y="280"/>
		</transition>
		<transition>
			<source ref="id170"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="375" y="221">WritePrivateKeyToSRAM!</label>
			<nail x="552" y="238"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id170"/>
			<label kind="synchronisation" x="212" y="221">WritePrivateKey?</label>
			<nail x="204" y="238"/>
		</transition>
		<transition>
			<source ref="id171"/>
			<target ref="id177"/>
			<label kind="assignment" x="-204" y="-280">unscramble()</label>
			<nail x="-272" y="-255"/>
			<nail x="-34" y="-255"/>
		</transition>
		<transition>
			<source ref="id176"/>
			<target ref="id171"/>
			<label kind="synchronisation" x="-399" y="-170">ReadSRAMScrambled[index]!</label>
		</transition>
		<transition>
			<source ref="id172"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="187">WriteSignatureToSRAM!</label>
			<nail x="552" y="204"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id172"/>
			<label kind="synchronisation" x="212" y="187">WriteSignature?</label>
			<nail x="195" y="204"/>
		</transition>
		<transition>
			<source ref="id183"/>
			<target ref="id174"/>
			<label kind="synchronisation" x="637" y="34">SignalSRAMWriteReturn!</label>
			<label kind="assignment" x="637" y="51">GlobalMemoryIsScrambled = false</label>
			<nail x="629" y="119"/>
			<nail x="629" y="0"/>
		</transition>
		<transition>
			<source ref="id182"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="153">WriteBootPolicyToSRAM!</label>
			<nail x="552" y="170"/>
		</transition>
		<transition>
			<source ref="id181"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="119">WriteImageCodeToSRAM!</label>
			<nail x="552" y="136"/>
		</transition>
		<transition>
			<source ref="id180"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="85">WritePublicKeyToSRAM!</label>
			<nail x="552" y="102"/>
		</transition>
		<transition>
			<source ref="id179"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="51">WriteManifestToSRAM!</label>
			<nail x="552" y="68"/>
		</transition>
		<transition>
			<source ref="id178"/>
			<target ref="id183"/>
			<label kind="synchronisation" x="382" y="17">WriteDigestToSRAM!</label>
			<nail x="552" y="34"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id178"/>
			<label kind="synchronisation" x="212" y="17">WriteDigest?</label>
			<nail x="195" y="34"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id179"/>
			<label kind="synchronisation" x="212" y="51">WriteManifest?</label>
			<nail x="195" y="68"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id180"/>
			<label kind="synchronisation" x="212" y="85">WritePublicKey?</label>
			<nail x="195" y="102"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id181"/>
			<label kind="synchronisation" x="212" y="110">WriteImageCode?</label>
			<nail x="195" y="136"/>
		</transition>
		<transition>
			<source ref="id173"/>
			<target ref="id182"/>
			<label kind="synchronisation" x="212" y="153">WriteBootPolicy?</label>
			<nail x="195" y="170"/>
		</transition>
		<transition>
			<source ref="id174"/>
			<target ref="id173"/>
			<label kind="synchronisation" x="42" y="42">SignalSRAMWrite?</label>
			<label kind="assignment" x="67" y="59">scramble()</label>
			<nail x="170" y="0"/>
		</transition>
		<transition>
			<source ref="id177"/>
			<target ref="id174"/>
			<label kind="guard" x="442" y="-212">!manifestEquals(GlobalManifest,GlobalEmptyManifest) ||
!publicKeyEquals(GlobalPublicKey, GlobalEmptyPublicKey) ||
GlobalDigest != 0 || 
GlobalImageCode != 0 || 
!bootPolicyEquals(GlobalBootPolicy,GlobalEmptyBootPolicy) ||
GlobalSignature != 0 ||
GlobalPublicKeyIdWhitelist[0] != -1</label>
			<label kind="synchronisation" x="442" y="-76">SignalSRAMReadReturn!</label>
			<nail x="425" y="-221"/>
			<nail x="425" y="-34"/>
			<nail x="0" y="-34"/>
		</transition>
		<transition>
			<source ref="id176"/>
			<target ref="id177"/>
			<label kind="synchronisation" x="-187" y="-212">ReadSRAM[index]!</label>
		</transition>
		<transition>
			<source ref="id184"/>
			<target ref="id175"/>
			<label kind="synchronisation" x="-416" y="-42">RequestSRAMScramblingKey!</label>
		</transition>
		<transition>
			<source ref="id175"/>
			<target ref="id174"/>
			<label kind="synchronisation" x="-255" y="0">ReturnSRAMScramblingKey?</label>
			<label kind="assignment" x="-255" y="17">scrambleKey = GlobalOTPStorage,
GlobalOTPStorage = 0</label>
		</transition>
		<transition>
			<source ref="id177"/>
			<target ref="id174"/>
			<label kind="guard" x="-25" y="-195">manifestEquals(GlobalManifest,GlobalEmptyManifest) &amp;&amp;
publicKeyEquals(GlobalPublicKey, GlobalEmptyPublicKey) &amp;&amp;
GlobalDigest == 0 &amp;&amp; 
GlobalImageCode == 0 &amp;&amp; 
bootPolicyEquals(GlobalBootPolicy, GlobalEmptyBootPolicy) &amp;&amp;
GlobalSignature == 0 &amp;&amp;
GlobalPublicKeyIdWhitelist[0] == -1</label>
			<label kind="synchronisation" x="-25" y="-68">NotInSRAM!</label>
		</transition>
		<transition>
			<source ref="id174"/>
			<target ref="id176"/>
			<label kind="select" x="-348" y="-85">s : int[0,NumberOfFieldsInSRAM - 1]</label>
			<label kind="synchronisation" x="-254" y="-68">SignalSRAMRead[s]?</label>
			<label kind="assignment" x="-178" y="-51">index = s</label>
		</transition>
	</template>
	<template>
		<name>MemoryHandling</name>
		<declaration>int s = -1;
int e = -1;
int FieldToCheck;

bool writingSRAM = false;

bool skipWriteToSRAM(){
  return !((GlobalBootPolicy != GlobalEmptyBootPolicy) || 
           (GlobalImageCode != 0) || 
           (GlobalDigest != 0) || 
           (GlobalPublicKey != GlobalEmptyPublicKey) || 
           (GlobalManifest != GlobalEmptyManifest) || 
           (GlobalSignature != 0) ||
           (GlobalPublicKeyIdWhitelist[0] != -1));
}</declaration>
		<location id="id185" x="-12138" y="-12002">
			<name x="-12146" y="-12036">ChooseType</name>
		</location>
		<location id="id186" x="-12189" y="-12257">
		</location>
		<location id="id187" x="-12665" y="-12257">
		</location>
		<location id="id188" x="-12665" y="-12121">
		</location>
		<location id="id189" x="-12665" y="-12019">
		</location>
		<location id="id190" x="-11951" y="-12257">
		</location>
		<location id="id191" x="-12036" y="-12002">
		</location>
		<location id="id192" x="-12733" y="-12325">
		</location>
		<location id="id193" x="-12665" y="-12393">
		</location>
		<location id="id194" x="-12597" y="-12325">
		</location>
		<init ref="id187"/>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12435" y="-11865">GlobalPublicKeyIdWhitelist[0] != -1</label>
			<label kind="synchronisation" x="-12614" y="-11865">WritePublicKeyIdWhitelist!</label>
			<nail x="-12206" y="-11840"/>
			<nail x="-12622" y="-11840"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12495" y="-11900">GlobalPrivateKey != GlobalEmptyPublicKey</label>
			<label kind="synchronisation" x="-12614" y="-11900">WritePrivateKey!</label>
			<nail x="-12206" y="-11874"/>
			<nail x="-12614" y="-11874"/>
		</transition>
		<transition>
			<source ref="id191"/>
			<target ref="id188"/>
			<label kind="guard" x="-12384" y="-12146">skipWriteToSRAM()</label>
			<nail x="-12240" y="-12121"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-11942">GlobalSignature != 0</label>
			<label kind="synchronisation" x="-12614" y="-11942">WriteSignature!</label>
			<nail x="-12206" y="-11917"/>
			<nail x="-12614" y="-11917"/>
		</transition>
		<transition>
			<source ref="id188"/>
			<target ref="id187"/>
			<label kind="guard" x="-12639" y="-12189">writingSRAM</label>
			<label kind="synchronisation" x="-12639" y="-12172">WriteMemoryReturn!</label>
			<label kind="assignment" x="-12639" y="-12155">writingSRAM = false</label>
			<nail x="-12648" y="-12189"/>
		</transition>
		<transition>
			<source ref="id194"/>
			<target ref="id187"/>
			<label kind="synchronisation" x="-12614" y="-12299">CheckSRAMReturn!</label>
		</transition>
		<transition>
			<source ref="id193"/>
			<target ref="id194"/>
			<label kind="synchronisation" x="-12631" y="-12384">SignalSRAMReadReturn?</label>
		</transition>
		<transition>
			<source ref="id192"/>
			<target ref="id193"/>
			<label kind="synchronisation" x="-12928" y="-12393">SignalSRAMRead[FieldToCheck]!</label>
			<label kind="assignment" x="-12928" y="-12376">FieldToCheck = 0</label>
		</transition>
		<transition>
			<source ref="id187"/>
			<target ref="id192"/>
			<label kind="select" x="-12954" y="-12291">i : int[0, NumberOfFieldsInSRAM - 1]</label>
			<label kind="synchronisation" x="-12818" y="-12274">CheckSRAM[i]?</label>
			<label kind="assignment" x="-12826" y="-12257">FieldToCheck = i</label>
		</transition>
		<transition>
			<source ref="id189"/>
			<target ref="id188"/>
			<label kind="synchronisation" x="-12843" y="-12078">SignalSRAMWriteReturn?</label>
		</transition>
		<transition>
			<source ref="id190"/>
			<target ref="id191"/>
			<label kind="synchronisation" x="-11934" y="-12180">FlashReadReturn?</label>
			<nail x="-11951" y="-12002"/>
		</transition>
		<transition>
			<source ref="id191"/>
			<target ref="id185"/>
			<label kind="guard" x="-12129" y="-11993">!skipWriteToSRAM()</label>
			<label kind="synchronisation" x="-12129" y="-11976">SignalSRAMWrite!</label>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-12036">GlobalDigest != 0</label>
			<label kind="synchronisation" x="-12614" y="-12036">WriteDigest!</label>
			<nail x="-12206" y="-12019"/>
			<nail x="-12613" y="-12019"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-12061">GlobalImageCode != 0</label>
			<label kind="synchronisation" x="-12614" y="-12061">WriteImageCode!</label>
			<nail x="-12205" y="-12045"/>
			<nail x="-12614" y="-12044"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-12010">GlobalPublicKey != GlobalEmptyPublicKey</label>
			<label kind="synchronisation" x="-12614" y="-12010">WritePublicKey!</label>
			<nail x="-12206" y="-11985"/>
			<nail x="-12614" y="-11985"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-11976">GlobalManifest != GlobalEmptyManifest</label>
			<label kind="synchronisation" x="-12614" y="-11976">WriteManifest!</label>
			<nail x="-12206" y="-11951"/>
			<nail x="-12614" y="-11951"/>
		</transition>
		<transition>
			<source ref="id185"/>
			<target ref="id189"/>
			<label kind="guard" x="-12503" y="-12087">GlobalBootPolicy != GlobalEmptyBootPolicy</label>
			<label kind="synchronisation" x="-12614" y="-12087">WriteBootPolicy!</label>
			<nail x="-12206" y="-12070"/>
			<nail x="-12614" y="-12070"/>
		</transition>
		<transition>
			<source ref="id187"/>
			<target ref="id191"/>
			<label kind="synchronisation" x="-12282" y="-12223">WriteMemory?</label>
			<label kind="assignment" x="-12273" y="-12206">writingSRAM = true</label>
			<nail x="-12614" y="-12206"/>
			<nail x="-12036" y="-12206"/>
		</transition>
		<transition>
			<source ref="id188"/>
			<target ref="id187"/>
			<label kind="guard" x="-12801" y="-12197">!writingSRAM</label>
			<label kind="synchronisation" x="-12818" y="-12180">ReadMemoryReturn!</label>
			<label kind="assignment" x="-12724" y="-12163">s = -1,
e = -1</label>
			<nail x="-12682" y="-12189"/>
		</transition>
		<transition>
			<source ref="id186"/>
			<target ref="id190"/>
			<label kind="synchronisation" x="-12121" y="-12282">FlashRead[s][e]!</label>
		</transition>
		<transition>
			<source ref="id187"/>
			<target ref="id186"/>
			<label kind="select" x="-12435" y="-12359">startIndex: int[0, MemoryMaxIndex - 1],
endIndex: int[0, MemoryMaxIndex - 1]</label>
			<label kind="synchronisation" x="-12435" y="-12325">ReadMemory[startIndex][endIndex]?</label>
			<label kind="assignment" x="-12435" y="-12308">s = startIndex,
e = endIndex</label>
		</transition>
	</template>
	<template>
		<name>SRAM</name>
		<declaration>pub_key_t publicKey;
int digest;
int[0,2] imageCode; 
int[-1,1] publicKeyIdWhitelist[NumberOfKeysInWhitelist];
boot_policy_t bootPolicy;
rom_exts_manifests_t manifests;
int signature;
pub_key_t privateKey;
bool scrambled[7];

int loopIndex;

void readSRAM(int e){
    if(e == 0)
        GlobalBootPolicy = bootPolicy;
    else if (e == 1)
        GlobalDigest = digest;
    else if (e == 2)
        GlobalImageCode = imageCode;
    else if (e == 3) 
        GlobalRomExtsManifests = manifests;
    else if (e == 4)
        GlobalPublicKey = publicKey;
    else if (e == 5)
        GlobalSignature = signature;
    else if (e == 6)
        GlobalPublicKey = privateKey;
    else if (e == 7)
        GlobalPublicKeyIdWhitelist = publicKeyIdWhitelist;
}

bool indexIsEmpty(int i){
    if (i == 0)
        return GlobalEmptyBootPolicy == bootPolicy;
    else if (i == 1)
        return 0 == digest;
    else if (i == 2)
        return 0 == imageCode;
    else if (i == 3)
        return GlobalEmptyManifests == manifests;
    else if (i == 4)
        return GlobalEmptyPublicKey == publicKey;
    else if (i == 5)
        return 0 == signature;
    else if (i == 6)
        return GlobalEmptyPublicKey == privateKey;
    else if (i == 7)
        return publicKeyIdWhitelist[0] == -1;
    else
        return false;
    
}
void storeManifest(rom_ext_manifest_t manifest){
    manifests.rom_exts_mfs[loopIndex] = manifest;
    loopIndex = (1 + loopIndex) % NumberOfFlashBanks;
}

void returnManifests(){
    GlobalRomExtsManifests = manifests;
    GlobalRomExtsManifests.size = NumberOfFlashBanks;
}

void updateScramble(int i){
    scrambled[i] = true;
}</declaration>
		<location id="id195" x="-1759" y="-2184">
		</location>
		<init ref="id195"/>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-2074" y="-2261">WriteKeyIdWhitelistToSRAM?</label>
			<label kind="assignment" x="-2074" y="-2244">publicKeyIdWhitelist = GlobalPublicKeyIdWhitelist,
ClearGlobalKeyIdList(),
updateScramble(7)</label>
			<nail x="-2184" y="-2184"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-2176" y="-2354">WritePrivateKeyToSRAM?</label>
			<label kind="assignment" x="-2176" y="-2337">privateKey = GlobalPrivateKey,
GlobalPrivateKey = GlobalEmptyPublicKey,
updateScramble(6)</label>
			<nail x="-1759" y="-2269"/>
			<nail x="-2184" y="-2269"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="select" x="-1657" y="-2295">e : int[0, NumberOfFieldsInSRAM - 1]</label>
			<label kind="guard" x="-1657" y="-2278">scrambled[e]</label>
			<label kind="synchronisation" x="-1657" y="-2261">ReadSRAMScrambled[e]?</label>
			<label kind="assignment" x="-1657" y="-2244">readSRAM(e)</label>
			<nail x="-1666" y="-2210"/>
			<nail x="-1666" y="-2312"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-1938" y="-2431">WriteSignatureToSRAM?</label>
			<label kind="assignment" x="-1938" y="-2414">signature = GlobalSignature,
GlobalSignature = 0,
updateScramble(5)</label>
			<nail x="-1759" y="-2771"/>
			<nail x="-2184" y="-2771"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-2176" y="-2516">WritePublicKeyToSRAM?</label>
			<label kind="assignment" x="-2176" y="-2499">publicKey = GlobalPublicKey,
clearGlobalPublicKey(),
updateScramble(4)</label>
			<nail x="-1759" y="-2354"/>
			<nail x="-2184" y="-2354"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-1904" y="-2763">WriteDigestToSRAM?</label>
			<label kind="assignment" x="-1904" y="-2746">digest = GlobalDigest,
GlobalDigest = 0,
updateScramble(1)</label>
			<nail x="-1759" y="-2193"/>
			<nail x="-1759" y="-2686"/>
			<nail x="-2184" y="-2686"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-1955" y="-2592">WriteManifestToSRAM?</label>
			<label kind="assignment" x="-1955" y="-2575">storeManifest(GlobalManifest),
returnManifests(),
updateScramble(3)</label>
			<nail x="-1759" y="-2601"/>
			<nail x="-2183" y="-2602"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-2176" y="-2847">WriteBootPolicyToSRAM?</label>
			<label kind="assignment" x="-2176" y="-2830">bootPolicy = GlobalBootPolicy,
clearGlobalBootPolicy(),
updateScramble(0)</label>
			<nail x="-1759" y="-2440"/>
			<nail x="-2184" y="-2440"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="synchronisation" x="-2176" y="-2677">WriteImageCodeToSRAM?</label>
			<label kind="assignment" x="-2176" y="-2660">imageCode = GlobalImageCode,
GlobalImageCode = 0,
updateScramble(2)</label>
			<nail x="-1759" y="-2516"/>
			<nail x="-2184" y="-2516"/>
			<nail x="-2184" y="-2125"/>
			<nail x="-1759" y="-2125"/>
		</transition>
		<transition>
			<source ref="id195"/>
			<target ref="id195"/>
			<label kind="select" x="-1657" y="-2125">e: int[0, NumberOfFieldsInSRAM-1]</label>
			<label kind="guard" x="-1657" y="-2108">!scrambled[e]</label>
			<label kind="synchronisation" x="-1657" y="-2091">ReadSRAM[e]?</label>
			<label kind="assignment" x="-1657" y="-2074">readSRAM(e)</label>
			<nail x="-1666" y="-2142"/>
			<nail x="-1666" y="-2040"/>
		</transition>
	</template>
	<system>system SystemReset, ROMStage, Flash, RomExtManifestsToTry, CheckPubKeyValid, VerifyRomExtSignature, 
       OTBN, RomExt, PmpModule, Zeno, FinalJumpToRomExt, ReadBootPolicy, CheckRomExtManifest,
       ExceptionHandler, ReadPublicKey, LifeCycleController, FlashController, SRAMController, 
       SRAM, MemoryHandling, ManifestObserver, OTP, OTPController, EDN, EntropySource, CSRNG, HASH;
    </system>
	<queries>
		<query>
			<formula>A[] ROMStage.IdentifierChecked imply ROMStage.currentManifest.identifier == 1</formula>
			<comment>Q1 Checking Manifest identifier.                                                                                                                                                                                       
This query is a safety property that verifies that the ROMStage template can only enter 
the IdentifierChecked location if the identifier of the current manifest is valid (a valid 
identifier in the model is represented with a 1).\\</comment>
		</query>
		<query>
			<formula>A[] (CheckRomExtManifest.manifest.identifier == 1) == CheckRomExtManifest.checkRomExtManifest()</formula>
			<comment>Q2: Checking valid manifest identifier.                                                                                                                                                                                       
This safety property says that the locally defined checkRomExtManifest function will return true, if and only if the 
CheckRomExtManifest template's local manifest has an identifier of 1. This query verifies the checkRomExtManifest
function. This means that the function behaves like we expect it does. Furthermore, the query also verifies that 1 is a 
correct value for the rom ext manifest's identifier.</comment>
		</query>
		<query>
			<formula>A[] ROMStage.CheckingSignature imply 
(ROMStage.currentManifest.identifier == 1 &amp;&amp; 
 ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp; 
 ROMStage.currentManifest.publicKey.exponent == 1)</formula>
			<comment>Q3: Checking Public Key.                                                                                                                                                                                         
This query is a safety property that works similar to the one described before. The difference here is that we add another 
part to the query regarding checking the public key of the manifest. Here we state that if the ROMStage template 
is in the CheckingSignature location, then the current manifest must have a valid identifier and a valid public key 
(a valid public key in the model is represented as having its modulus and exponent both equal to 1).</comment>
		</query>
		<query>
			<formula>A[] ROMStage.CheckedSignature imply (ROMStage.currentManifest.identifier == 1 &amp;&amp; ROMStage.currentManifest.publicKey.modulus == 1 &amp;&amp;ROMStage.currentManifest.publicKey.exponent == 1 &amp;&amp;ROMStage.currentManifest.signature == 1)</formula>
			<comment>Q4: Checking Signature.                                                                                                                                                                                          
This query is also a safety property that is similar to the two previous ones. 
This one adds that if the ROMStage template is in the CheckedSignature location, 
then the signature of the current manifest must be valid as well as the identifier and 
public key (a valid signature is represented as 1 in the model).</comment>
		</query>
		<query>
			<formula>A[] ROMStage.ReadyToRunROMExt imply (PmpRegions[0].execute &amp;&amp; PmpRegions[0].startAddress &lt;= ROMStage.currentManifest.entryPoint &amp;&amp; PmpRegions[0].endAddress &gt;= ROMStage.currentManifest.entryPoint + 4)</formula>
			<comment>Q5: PMP Execute.                                                                                                                                                                                                 
This query is a safety property that states that if the ROMStage template is in 
the ReadyToRunROMExt location, then the the first PMP region must allow for the 
ROM_ext manifest image code to be executed.</comment>
		</query>
		<query>
			<formula>A[] (CheckPubKeyValid.currentPubKeyId == 1) == CheckPubKeyValid.checkPublicKey()</formula>
			<comment>Q6: Valid Key Id.                                                                                                                                                                                                
This safety property states that whenever the CheckPubKeyValid's currentPubKeyId 
is equal to 1 (i.e. a correct public key id), then the locally declared checkPublicKey will
return true. This query verifies the checkPublicKey function, so we know it behaves like 
we expect it to behave.</comment>
		</query>
		<query>
			<formula>(CheckPubKeyValid.publicKey.exponent == 1 &amp;&amp;
CheckPubKeyValid.publicKey.modulus == 1) --&gt; 
CheckPubKeyValid.currentPubKeyId == 1</formula>
			<comment>Q7: Valid Key Leads to Valid Key Id.                                                                                                                                                                                       
(CheckPubKeyValid.publicKey.exponent == 1 &amp;&amp; CheckPubKeyValid.publicKey.modulus == 1) --&gt; CheckPubKeyValid.currentPubKeyId == 1</comment>
		</query>
		<query>
			<formula>A[] (OTBN.signature == 1 &amp;&amp; OTBN.digest == 3 &amp;&amp; OTBN.key.modulus == 1 &amp;&amp; OTBN.key.exponent == 1) == OTBN.checkSignature()</formula>
			<comment>Q8 : Valid Signature.                                                                                                                                                                                            
This is a safety property. It says that the OTBN template has the correct signature, 
key, and digest values, if and only if the locally declared checkSignature will evaluate to 
true. This query verifies the checkSignature function in the positive and negative case.</comment>
		</query>
		<query>
			<formula>EqualManifestContents(validManifest,ROMStage.currentManifest) --&gt; (FinalJumpToRomExt.ROM_ext_running &amp;&amp; EqualManifestContents(validManifest,ROMStage.currentManifest))</formula>
			<comment>Q9: Valid Manifest Leads to Rom Ext Running.                                                                                                                                                                                       
This query is a liveness query. It says that whenever the the current manifest in the ROMStage
template is equal to a hypothetically correct manifest, then the FinalJumpToRomExt template will 
eventually be in the ROM_ext_running location, and the current manifest in the ROMStage
template will still be equal to the correct manifest. The variable validManifest is a global variable 
of the type rom_ext_manifest_t, which is considered correct with respect to the three checks made 
by the ROMStage template. The function EqualManifestContents is a globally defined boolean 
function that returns whether two given rom_ext_manifest_ts have the same identifier, public key, and signature.</comment>
		</query>
		<query>
			<formula>!EqualManifestContents(validManifest,ROMStage.currentManifest) --&gt; (ROMStage.StartOfLoop || ROMStage.Boot_Failed)</formula>
			<comment>Q10: Invalid Manifest Leads to Failure.                                                                                                                                                                                       
This liveness property says that if the current manifest in the ROMStage template is different from 
validManifest, which is the only values of manifests that can pass all the checks in the ROMStage
template, then the ROMStage template will eventually go back to the StartOfLoop or 
Boot_Failed locations, which means that the manifest has failed at least one check.</comment>
		</query>
		<query>
			<formula>(CheckPubKeyValid.publicKey.exponent != 1 || CheckPubKeyValid.publicKey.modulus != 1) --&gt; CheckPubKeyValid.currentPubKeyId == 0</formula>
			<comment>Q11: Invalid key Leads to Invalid Key Id.                                                                                                                                                                                       
This liveness property can be seen as a compliment to Q7. It says that whenever the public key 
has a public key where either the modulus or the exponent is different from 0, then the resulting
public key id will be 0. Together with Q7, this query says that the calculated public key id 
depends on the value of the given public key.</comment>
		</query>
		<query>
			<formula>A[] !ManifestObserver.Failure</formula>
			<comment>Q12: Never Failure.                                                                                                                                                                                              
This query says that the ManifestObserver template never reaches the Failure location. 
Verifying this query means that we know that the manifest (including its signature and image code fields) 
never changes between passed checks. This property does not verify that the FinalJumpToRomExt 
template receives the same manifest, since there might be a deadlock before ManifestObserver
template reaches the Failure location.</comment>
		</query>
		<query>
			<formula>A[] FinalJumpToRomExt.ROMExtRunning imply ManifestObserver.Success</formula>
			<comment>Q13: Verify Observer.                                                                                                                                                                                            
This query says that as long as the FinalJumpToRomExt template is in the ROMExtRunning location, 
then the ManifestObserver template must be in the Success location. This means that Whenever the
 ROM_ext is running, then the three checks required for the Mask_rom to boot are passed, and the manifest has not 
changed in the process.</comment>
		</query>
		<query>
			<formula>A[] SRAM.indexIsEmpty(6)</formula>
			<comment>Q14: Never in SRAM.                                                                                                                                                                                              
This query is a safety property. It says that the sixth index in the SRAM is always empty. 
That index is exclusively used for private and secret keys. By verifying this property we 
ensure that secret keys and private keys are never stored in the SRAM. </comment>
		</query>
		<query>
			<formula>A[] FinalJumpToRomExt.ROMExtRunning imply forall (i : int[0, 6]) (SRAM.scrambled[i] || SRAM.indexIsEmpty(i))</formula>
			<comment>Q15: Check SRAM Scrambled.                                                                                                                                                                                       
This query is a safety property that uses local variables and functions in the SRAM template to 
check that all fields of SRAM are either scrambled or empty when the model is in a state that
 contains the ROMExtRunning location of the FinalJumpToRomExt template.</comment>
		</query>
		<query>
			<formula>A[] FinalJumpToRomExt.ROMExtRunning imply forall (i : int[0,6]) SRAM.indexIsEmpty(i)</formula>
			<comment>Q16: Check SRAM Wiped.                                                                                                                                                                                            
This query is almost identical to Q14. However, this query only passes if every field of SRAM
is empty i.e. wiped. This property does not pass, which means that not all of the data in the SRAM
is wiped. Q11 tells us that the data that is not wiped is scrambled.</comment>
		</query>
		<query>
			<formula>A[] FinalJumpToRomExt.ROMExtRunning imply exists (i : int[0,5]) SRAM.indexIsEmpty(i)</formula>
			<comment>Q17: Check Some of SRAM wiped.                                                                                                                                                                                       
This safety query says that whenever the FinalJumpToRomExt is in the ROMExtRunning 
location (i.e. what we consider a successful boot of the rom stage), then the SRAM contents between 
indices 0 and 5 must be empty. Since we know that all of the indices are set during the ROM stage, we 
know that if they are empty, they must have been cleared. The query does not pass. Using a diagnostic 
trace, we can see that there exists a trace where index 0-5 of the SRAM template is not empty, 
while the FinalJumpToRomExt template is in the ROMExtRunning location. Since this query 
fails, we know that none of the contents are cleared. The reason that this query specifies the indices 0 to 
5 as opposed to 0 to 6 like the other queries in this section is because we know that index 6 is never written 
to, and will therefore always appear empty.</comment>
		</query>
		<query>
			<formula>A[] !ExceptionHandler.ExceptionRaised</formula>
			<comment>Q18: Exception Raised.                                                                                                                                                                                            
If the ExceptionHandler template ever reaches the ExceptionRaised location, an invalid read, write, or 
execute request has been issued. By executing this query we have verified that no invalid requests are made.</comment>
		</query>
		<query>
			<formula>A[] !PmpModule.BadRead</formula>
			<comment>Q19: Never Negative Case - Read.                                                                                                                                                                                       
If the PmpModule template is ever in the BadRead location, then an invalid read request has been issued. 
By verifying this query, it is verified that such a request has not been made. </comment>
		</query>
		<query>
			<formula>A[] !PmpModule.BadWrite</formula>
			<comment>Q20: Never Negative Case - Write.                                                                                                                                                                                       
If the PmpModule template is ever in the BadWrite location, then an invalid read request has been issued. 
By verifying this query, it is verified that such a request has not been made. </comment>
		</query>
		<query>
			<formula>A[] !PmpModule.BadExecute</formula>
			<comment>Q21: Never Negative Case - Execute.                                                                                                                                                                                       
If the PmpModule template is ever in the BadExecute location, then an invalid read request has been issued. 
By verifying this query, it is verified that such a request has not been made. </comment>
		</query>
		<query>
			<formula>A[] PmpModule.GoodRead imply (exists (pmpIndex : int[0,15]) PmpRegions[pmpIndex].startAddress &lt;= PmpModule.start &amp;&amp; PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;  PmpRegions[pmpIndex].read)</formula>
			<comment>Q22: Positive Case - read                                                                                                                                                                                        
This query says that whenever the PmpModule template reaches the GoodRead location, 
then there is a PMP region that allows for reading that section of memory. </comment>
		</query>
		<query>
			<formula>A[] PmpModule.GoodWrite imply (exists (pmpIndex : int[0,15]) PmpRegions[pmpIndex].startAddress &lt;= PmpModule.start &amp;&amp; PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;  PmpRegions[pmpIndex].write)</formula>
			<comment>Q23: Positive Case - write                                                                                                                                                                                       
This query says that whenever the PmpModule template reaches the GoodWrite location, 
then there is a PMP region that allows for reading that section of memory. </comment>
		</query>
		<query>
			<formula>A[] PmpModule.GoodExecute imply (exists (pmpIndex : int[0,15]) PmpRegions[pmpIndex].startAddress &lt;= PmpModule.start &amp;&amp; PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;  PmpRegions[pmpIndex].execute)</formula>
			<comment>Q24: Positive Case - execute                                                                                                                                                                                       
This query says that whenever the PmpModule template reaches the GoodExecute location, 
then there is a PMP region that allows for executing that section of memory.</comment>
		</query>
		<query>
			<formula>A[] PmpModule.BadRead imply (!(exists (pmpIndex : int[0,15])
PmpRegions[pmpIndex]. startAddress &lt;= PmpModule.start &amp;&amp; 
PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;
PmpRegions[pmpIndex].read))</formula>
			<comment>Q25: Negative case - read.                                                                                                                                                                                        
This query says that whenever the PmpModule template reaches the BadRead location, 
then a PMP region that allows for reading that section of memory does not exist. If the PmpModule 
template reaches the BadRead location, then the PmpModule template will reject the request, 
and will not communicate with the Flash template. </comment>
		</query>
		<query>
			<formula>A[] PmpModule.BadWrite imply (!(exists (pmpIndex : int[0,15])
PmpRegions[pmpIndex]. startAddress &lt;= PmpModule.start &amp;&amp; 
PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;
PmpRegions[pmpIndex].write))</formula>
			<comment>Q26: Negative case - write.                                                                                                                                                                                       
This query says that whenever the PmpModule template reaches the BadWrite location, 
then a PMP region that allows for reading that section of memory does not exist. If the PmpModule 
template reaches the BadWrite location, then the PmpModule template will reject the request, 
and will not communicate with the Flash template. </comment>
		</query>
		<query>
			<formula>A[] PmpModule.BadExecute imply (!(exists (pmpIndex : int[0,15])
PmpRegions[pmpIndex]. startAddress &lt;= PmpModule.start &amp;&amp; 
PmpRegions[pmpIndex].endAddress &gt;= PmpModule.end &amp;&amp;
PmpRegions[pmpIndex].execute))</formula>
			<comment>Q27: Negative case - execute.                                                                                                                                                                                       
This query says that whenever the PmpModule template reaches the BadExecute location, 
then a PMP region that allows for executing that section of memory does not exist. If the PmpModule 
template reaches the BadExecute location, then the PmpModule template will reject the request, 
and will not communicate with the Flash template. </comment>
		</query>
		<query>
			<formula>E&lt;&gt; PmpModule.GoodRead</formula>
			<comment>Q28: Positive case possible - read.                                                                                                                                                                                       
This query says that a path from the initial location to a state where the PmpModule template 
is in the GoodRead location exists. It is used to make sure that some of the other queries that 
imply something based on whether the PmpModule template is in this location. We have also verified 
this query for writing and executing as well. </comment>
		</query>
		<query>
			<formula>E&lt;&gt; PmpModule.GoodWrite</formula>
			<comment>Q29: Positive case possible - write.                                                                                                                                                                                       
This query says that a path from the initial location to a state where the PmpModule template 
is in the GoodRead location exists. It is used to make sure that some of the other queries that 
imply something based on whether the PmpModule template is in this location. We have also verified 
this query for writing and executing as well. Notably, this query fails, meaning 
that a valid writing request is never made.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; PmpModule.GoodExecute</formula>
			<comment>Q30: Positive case possible - execute.                                                                                                                                                                                       
This query says that a path from the initial location to a state where the PmpModule template is in the GoodExecute location exists. 
It is used to make sure that some of the other queries that imply something based on whether the PmpModule template is in 
this location. </comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>E[] not( ROMStage.BootFailed || ROMStage.RomExtTerminated)</formula>
			<comment>D1: Possibly Never Fail.                                                                                                                                                                                         
This query states that there exists a path such that it always holds that the ROMStage 
template never enters one of the two failure locations: BootFailed or RomExtTerminated. 
When run on the current model it passes, which means that there exists at least one trace where the 
ROMStage template does not end in one of the two failure locations. This is what we expect 
of a correct model. </comment>
		</query>
		<query>
			<formula>A[] not( ROMStage.BootFailed || ROMStage.RomExtTerminated)</formula>
			<comment>D2: Guaranteed Never Fail.                                                                                                                                                                                       
This query states the same as D1, except that for this query to be true, it must hold for all paths 
(due to the use of A[]). This query does not pass in the current model, which is what we 
expect since not all ROM_ext manifests should be valid. When we ask for a diagnostic trace in uppaal, 
we get a counterexample in the form of a trace where the ROMStage template ends in the 
BootFailed location.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; FinalJumpToRomExt.ROMExtRunning</formula>
			<comment>D3: Success Possible.                                                                                                                                                                                            
While D1 and D2 together state that some, but not all traces through the model should lead to a failure state, 
they do not express that any traces should lead to a success state. For this we use D3 and D4. D3 is a reachability 
property that states that there exists a path such that the state of the system eventually contains the ROMExtRunning 
location of the FinalJumpToRomExt template. This is a state where ROMStage has successfully 
transferred execution to the RomExt template. This query passes for the current model, which is what 
we expect because there should be a valid manifest that leads to this outcome.</comment>
		</query>
		<query>
			<formula>A&lt;&gt; FinalJumpToRomExt.ROMExtRunning</formula>
			<comment>D4: Success Guaranteed.                                                                                                                                                                                          
This is a simple liveness property. It says that independent of which transitions are taken, the \uppTemp{FinalJumpToRomExt} 
template will eventually be in the ROMExtRunning location, which is our version of our success state. This query 
does not pass, which means that it is possible to not always reach this state. This is what we expect as not all manifests
are valid. The diagnostic trace that we can get from uppaal confirms that there is indeed a counterexample trace, which
leads to the BootFailed location in the ROMStage template.</comment>
		</query>
		<query>
			<formula>A[] !ExceptionHandler.ExceptionRaised</formula>
			<comment>D5: Exception Never Raised.                                                                                                                                                                                       
This is a safety property. It says that the ExceptionHandler is never able to reach the ExceptionRaised location. 
This would happen if the PmpModule template receives a bad request for reading, writing, or executing, or if the SRAMController
template receives a read request for something that is not in SRAM.</comment>
		</query>
		<query>
			<formula>A[] FinalJumpToRomExt.ROMExtRunning imply GlobalMemoryIsScrambled == false</formula>
			<comment>D6: Memory Unscramble Urgent.                                                                                                                                                                                       
This is a safety property. It says that whenever the FinalJumpToRomExt template is in the ROMExtRunning location, 
then the global variable GlobalMemoryIsScrambled must be false. This query validates that unscrambling 
memory that has been read cannot be delayed until the end of the ROMStage template.</comment>
		</query>
		<query>
			<formula>A[] FlashController.ScrambleCheck imply !GlobalMemoryIsScrambled</formula>
			<comment>D7: Flash Immediately Unscrambled.                                                                                                                                                                                       
This is a safety property. It says that whenever the FlashController template is in the ScrambleCheck location, 
then the global variable GlobalMemoryIsScrambled must be false. This further validates that flash memory that is read is unscrambled immediately.</comment>
		</query>
		<query>
			<formula>A[] SRAMController.ScrambleCheck imply !GlobalMemoryIsScrambled</formula>
			<comment>D8: SRAM Immediately Unscrambled.                                                                                                                                                                                       
This is a safety property very similar to D7. This query checks whether 
SRAM memory that is read is immediately unscrambled.</comment>
		</query>
		<query>
			<formula>A[] 
 MemoryHandling.ChooseType imply
(((GlobalBootPolicy != GlobalEmptyBootPolicy) +
  (GlobalImageCode != 0) +
  (GlobalDigest != 0) +
  (GlobalPublicKey != GlobalEmptyPublicKey) + 
  (GlobalManifest != GlobalEmptyManifest) +
  (GlobalSignature != 0) +
  (GlobalPrivateKey != GlobalEmptyPublicKey) +
  (GlobalPublicKeyIdWhitelist[0] != -1)) == 1)</formula>
			<comment>D9: Exactly One Choice.                                                                                                                                                                                          
This safety property says that whenever the \uppTemp{MemoryHandling} template is in the \uppLoc{ChooseType} location, 
then exactly one of the seven transitions must be active. We have made this query to validate that it is not possible 
to read more than one thing form the \uppTemp{SRAM} at a time. To verify this, we sum the guards, and check whether it 
is equal to 1. The guards are boolean, but their values are represented as 0 or 1. If their sum is equal to one, then 
exactly one of the guards must be true.</comment>
		</query>
		<query>
			<formula>A[] !PmpModule.canWrite(30 + 35 * ROMStage.loopIndex, 41 + 35 * ROMStage.loopIndex)</formula>
			<comment>D10: Writing Manifest is Disallowed.                                                                                                                                                                                       
This is a safety property. It says that according to the \uppTemp{PmpModule} template it is never possible 
to write anything to the specific range of memory where the currentManifest is placed. This query validates
that it is impossible to change the manifests by writing to flash.</comment>
		</query>
	</queries>
</nta>
